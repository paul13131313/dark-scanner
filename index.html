<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>DARK SCANNER — Tactical Image Analysis</title>

<!-- OGP -->
<meta property="og:title" content="DARK SCANNER">
<meta property="og:description" content="MediaPipeで人物・顔・ポーズを検出し、CIA/軍事偵察分析風のダークテックHUDで加工する画像ジェネレーター">
<meta property="og:image" content="https://paul13131313.github.io/dark-scanner/ogp.png">
<meta property="og:url" content="https://paul13131313.github.io/dark-scanner/">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">

<!-- Favicon -->
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%23000'/><text x='50' y='62' text-anchor='middle' font-size='50' fill='%23fff'>⊕</text></svg>">

<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000; color: #fff;
    font-family: 'Share Tech Mono', 'SF Mono', 'Fira Code', 'Courier New', monospace;
    overflow: hidden; text-transform: uppercase;
    letter-spacing: 1px;
    -webkit-user-select: none; user-select: none;
    touch-action: manipulation;
  }

  /* ===== START SCREEN ===== */
  .screen { position: fixed; inset: 0; display: none; z-index: 10; }
  .screen.active { display: flex; }

  #start-screen {
    flex-direction: column; align-items: center; justify-content: center;
    background: #000;
  }
  #start-screen::before {
    content: ''; position: absolute; inset: 0;
    background:
      repeating-linear-gradient(0deg, transparent, transparent 79px, rgba(255,255,255,0.03) 79px, rgba(255,255,255,0.03) 80px),
      repeating-linear-gradient(90deg, transparent, transparent 79px, rgba(255,255,255,0.03) 79px, rgba(255,255,255,0.03) 80px);
    pointer-events: none;
  }
  .start-title {
    font-size: 28px; letter-spacing: 8px; font-weight: 700;
    color: rgba(255,255,255,0.9); margin-bottom: 8px; position: relative;
  }
  .start-sub {
    font-size: 10px; letter-spacing: 3px;
    color: rgba(255,255,255,0.3); margin-bottom: 6px;
  }
  .start-version {
    font-size: 9px; letter-spacing: 2px;
    color: rgba(255,255,255,0.15); margin-bottom: 40px;
  }
  #model-status {
    font-size: 10px; letter-spacing: 2px;
    color: rgba(255,255,255,0.4); margin-bottom: 30px;
    min-height: 16px;
  }
  .source-buttons {
    display: flex; flex-direction: column; gap: 12px;
    width: 220px; position: relative;
  }
  .source-btn {
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.7);
    padding: 16px 24px; font-size: 13px; letter-spacing: 3px;
    font-family: inherit; text-transform: uppercase;
    cursor: pointer; transition: all 0.3s;
    display: flex; align-items: center; justify-content: center; gap: 10px;
  }
  .source-btn:hover {
    background: rgba(255,255,255,0.1);
    border-color: rgba(255,255,255,0.4);
    color: #fff;
  }
  .source-btn:disabled {
    opacity: 0.2; cursor: default; pointer-events: none;
  }
  .source-btn .icon { font-size: 16px; }
  .start-footer {
    position: absolute; bottom: 30px;
    font-size: 9px; letter-spacing: 2px;
    color: rgba(255,255,255,0.1);
  }

  /* ===== CAMERA SCREEN ===== */
  #camera-screen {
    flex-direction: column; align-items: center; justify-content: center;
    background: #000;
  }
  #video {
    width: 100%; height: 100%; object-fit: cover;
    position: absolute; inset: 0;
  }
  .camera-hud {
    position: absolute; inset: 0; pointer-events: none;
  }
  .camera-corner {
    position: absolute; width: 30px; height: 30px;
    border-color: rgba(255,255,255,0.4); border-style: solid; border-width: 0;
  }
  .camera-corner.tl { top: 20px; left: 20px; border-top-width: 2px; border-left-width: 2px; }
  .camera-corner.tr { top: 20px; right: 20px; border-top-width: 2px; border-right-width: 2px; }
  .camera-corner.bl { bottom: 100px; left: 20px; border-bottom-width: 2px; border-left-width: 2px; }
  .camera-corner.br { bottom: 100px; right: 20px; border-bottom-width: 2px; border-right-width: 2px; }
  .camera-label {
    position: absolute; top: 30px; left: 50%;
    transform: translateX(-50%);
    font-size: 10px; letter-spacing: 3px;
    color: rgba(255,255,255,0.4);
  }
  .camera-actions {
    position: absolute; bottom: 0; left: 0; right: 0;
    display: flex; align-items: center; justify-content: center;
    padding: 20px; gap: 24px; z-index: 5;
    background: linear-gradient(transparent, rgba(0,0,0,0.8));
  }
  #btn-scan {
    width: 64px; height: 64px; border-radius: 50%;
    background: transparent;
    border: 3px solid rgba(255,255,255,0.8);
    cursor: pointer; position: relative;
    transition: all 0.2s;
  }
  #btn-scan::after {
    content: ''; position: absolute;
    top: 5px; left: 5px; right: 5px; bottom: 5px;
    border-radius: 50%;
    background: #ff3333;
    transition: all 0.2s;
  }
  #btn-scan:active::after { transform: scale(0.9); }
  .cam-ctrl-btn {
    width: 44px; height: 44px; border-radius: 50%;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.7);
    font-size: 18px; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    font-family: inherit;
  }
  #btn-back-start {
    position: absolute; top: 16px; left: 16px;
    width: 40px; height: 40px; border-radius: 50%;
    background: rgba(0,0,0,0.5);
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.7);
    font-size: 18px; cursor: pointer; z-index: 5;
    display: flex; align-items: center; justify-content: center;
    font-family: inherit;
  }

  /* ===== ANALYZING SCREEN ===== */
  #analyzing-screen {
    flex-direction: column; align-items: center; justify-content: center;
    background: #000;
  }
  .analyze-title {
    font-size: 14px; letter-spacing: 4px;
    color: rgba(255,255,255,0.7); margin-bottom: 24px;
  }
  .progress-bar {
    width: 260px; height: 4px;
    background: rgba(255,255,255,0.08); margin-bottom: 16px;
  }
  .progress-fill {
    height: 100%; width: 0%;
    background: #fff; transition: width 0.3s;
  }
  .analyze-detail {
    font-size: 9px; letter-spacing: 2px;
    color: rgba(255,255,255,0.3);
  }

  /* ===== RESULT SCREEN ===== */
  #result-screen {
    flex-direction: column; align-items: center; justify-content: center;
    background: #000; overflow: auto;
    -webkit-overflow-scrolling: touch;
  }
  #result-screen canvas {
    max-width: 100%; max-height: calc(100vh - 80px);
    object-fit: contain;
  }
  .result-actions {
    position: fixed; bottom: 0; left: 0; right: 0;
    display: flex; justify-content: center; gap: 12px;
    padding: 16px;
    background: linear-gradient(transparent, rgba(0,0,0,0.95));
    z-index: 15;
  }
  .result-btn {
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.25);
    color: rgba(255,255,255,0.8);
    padding: 12px 28px; font-size: 12px; letter-spacing: 3px;
    font-family: inherit; text-transform: uppercase;
    cursor: pointer; transition: all 0.3s;
    display: flex; align-items: center; gap: 8px;
  }
  .result-btn:hover {
    background: rgba(255,255,255,0.1);
    border-color: rgba(255,255,255,0.5);
    color: #fff;
  }
  .result-btn .icon { font-size: 14px; }
</style>
</head>
<body>

<!-- START SCREEN -->
<div id="start-screen" class="screen active">
  <div class="start-title">DARK SCANNER</div>
  <div class="start-sub">TACTICAL IMAGE ANALYSIS SYSTEM</div>
  <div class="start-version">RECON v3.1.0</div>
  <div id="model-status">INITIALIZING SYSTEM...</div>
  <div class="source-buttons">
    <button class="source-btn" id="btn-camera" disabled>
      <span class="icon">&#9711;</span> CAMERA
    </button>
    <button class="source-btn" id="btn-upload" disabled>
      <span class="icon">&#9645;</span> UPLOAD
    </button>
  </div>
  <input type="file" id="file-input" accept="image/*" hidden>
  <div class="start-footer">SYSTEM: STANDBY</div>
</div>

<!-- CAMERA SCREEN -->
<div id="camera-screen" class="screen">
  <video id="video" autoplay playsinline muted></video>
  <button id="btn-back-start">&larr;</button>
  <div class="camera-hud">
    <div class="camera-corner tl"></div>
    <div class="camera-corner tr"></div>
    <div class="camera-corner bl"></div>
    <div class="camera-corner br"></div>
    <div class="camera-label">SCANNING TARGET...</div>
  </div>
  <div class="camera-actions">
    <button class="cam-ctrl-btn" id="btn-flip">&#8635;</button>
    <button id="btn-scan"></button>
    <button class="cam-ctrl-btn" id="btn-gallery">&#9645;</button>
  </div>
</div>

<!-- ANALYZING SCREEN -->
<div id="analyzing-screen" class="screen">
  <div class="analyze-title">&#9654; ANALYZING...</div>
  <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
  <div class="analyze-detail" id="analyze-detail">INITIALIZING DETECTORS</div>
</div>

<!-- RESULT SCREEN -->
<div id="result-screen" class="screen">
  <canvas id="hud-canvas" width="1080" height="1920"></canvas>
  <div class="result-actions">
    <button class="result-btn" id="btn-save"><span class="icon">&#8681;</span> SAVE</button>
    <button class="result-btn" id="btn-new"><span class="icon">&#9711;</span> NEW</button>
  </div>
</div>

<script type="module">
import vision from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js';
const { ObjectDetector, FaceDetector, PoseLandmarker, FilesetResolver } = vision;

/* ===== STATE ===== */
let objectDetector = null;
let faceDetector = null;
let poseLandmarker = null;
let currentFacingMode = 'environment';
let currentStream = null;

/* ===== ELEMENTS ===== */
const startScreen = document.getElementById('start-screen');
const cameraScreen = document.getElementById('camera-screen');
const analyzingScreen = document.getElementById('analyzing-screen');
const resultScreen = document.getElementById('result-screen');
const modelStatus = document.getElementById('model-status');
const btnCamera = document.getElementById('btn-camera');
const btnUpload = document.getElementById('btn-upload');
const btnScan = document.getElementById('btn-scan');
const btnFlip = document.getElementById('btn-flip');
const btnGallery = document.getElementById('btn-gallery');
const btnBackStart = document.getElementById('btn-back-start');
const btnSave = document.getElementById('btn-save');
const btnNew = document.getElementById('btn-new');
const fileInput = document.getElementById('file-input');
const videoEl = document.getElementById('video');
const progressFill = document.getElementById('progress-fill');
const analyzeDetail = document.getElementById('analyze-detail');
const hudCanvas = document.getElementById('hud-canvas');
const hudCtx = hudCanvas.getContext('2d');

/* ===== CONSTANTS ===== */
const W = 1080;
const H = 1920;
const M = 30; // margin

/* ===== POSE CONNECTIONS ===== */
const POSE_CONNECTIONS = [
  [0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],
  [9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],
  [17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],
  [11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],
  [27,29],[28,30],[29,31],[30,32],[27,31],[28,32]
];

/* ===== SCREEN MANAGEMENT ===== */
function showScreen(id) {
  [startScreen, cameraScreen, analyzingScreen, resultScreen].forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

/* ===== MODEL INITIALIZATION ===== */
async function initModels() {
  try {
    modelStatus.textContent = 'LOADING VISION RUNTIME...';
    const filesetResolver = await FilesetResolver.forVisionTasks(
      'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm'
    );

    modelStatus.textContent = 'LOADING MODEL 1/3 — OBJECT DETECTOR...';
    objectDetector = await ObjectDetector.createFromOptions(filesetResolver, {
      baseOptions: {
        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/object_detector/efficientdet_lite0/float16/1/efficientdet_lite0.tflite',
        delegate: 'GPU'
      },
      maxResults: 10,
      scoreThreshold: 0.3,
      runningMode: 'IMAGE'
    });

    modelStatus.textContent = 'LOADING MODEL 2/3 — FACE DETECTOR...';
    faceDetector = await FaceDetector.createFromOptions(filesetResolver, {
      baseOptions: {
        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_detector/blaze_face_short_range/float16/1/blaze_face_short_range.tflite',
        delegate: 'GPU'
      },
      runningMode: 'IMAGE'
    });

    modelStatus.textContent = 'LOADING MODEL 3/3 — POSE LANDMARKER...';
    poseLandmarker = await PoseLandmarker.createFromOptions(filesetResolver, {
      baseOptions: {
        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task',
        delegate: 'GPU'
      },
      runningMode: 'IMAGE',
      numPoses: 5
    });

    modelStatus.textContent = 'ALL SYSTEMS OPERATIONAL';
    btnCamera.disabled = false;
    btnUpload.disabled = false;
    document.querySelector('.start-footer').textContent = 'SYSTEM: READY';
  } catch (e) {
    console.error('Model init error:', e);
    modelStatus.textContent = 'ERROR: ' + e.message;
  }
}

/* ===== CAMERA ===== */
async function startCamera() {
  try {
    if (currentStream) {
      currentStream.getTracks().forEach(t => t.stop());
    }
    currentStream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: currentFacingMode, width: { ideal: 1080 }, height: { ideal: 1920 } }
    });
    videoEl.srcObject = currentStream;
    await new Promise(r => { videoEl.onloadeddata = r; });
  } catch (e) {
    console.error('Camera error:', e);
    alert('CAMERA ACCESS DENIED');
    showScreen('start-screen');
  }
}

function stopCamera() {
  if (currentStream) {
    currentStream.getTracks().forEach(t => t.stop());
    currentStream = null;
  }
}

function captureFrame() {
  const c = document.createElement('canvas');
  c.width = videoEl.videoWidth;
  c.height = videoEl.videoHeight;
  const cx = c.getContext('2d');
  cx.drawImage(videoEl, 0, 0);
  return c;
}

/* ===== DETECTION ===== */
async function analyzeImage(imageSource) {
  showScreen('analyzing-screen');
  progressFill.style.width = '0%';

  analyzeDetail.textContent = 'RUNNING OBJECT DETECTION...';
  progressFill.style.width = '10%';
  await new Promise(r => setTimeout(r, 50));
  const t0 = performance.now();
  const objectResults = objectDetector.detect(imageSource);
  progressFill.style.width = '33%';

  analyzeDetail.textContent = 'RUNNING FACE DETECTION...';
  await new Promise(r => setTimeout(r, 50));
  const faceResults = faceDetector.detect(imageSource);
  progressFill.style.width = '66%';

  analyzeDetail.textContent = 'RUNNING POSE ESTIMATION...';
  await new Promise(r => setTimeout(r, 50));
  const poseResults = poseLandmarker.detect(imageSource);
  progressFill.style.width = '90%';

  const procTime = Math.round(performance.now() - t0);

  analyzeDetail.textContent = 'GENERATING HUD OVERLAY...';
  progressFill.style.width = '100%';
  await new Promise(r => setTimeout(r, 200));

  return { objectResults, faceResults, poseResults, procTime };
}

/* ===== FAKE DATA GENERATORS ===== */
function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function randFloat(min, max, dec) { return (Math.random() * (max - min) + min).toFixed(dec); }
function randHex(len) { return Array.from({length: len}, () => Math.floor(Math.random() * 16).toString(16)).join('').toUpperCase(); }

function formatTimestamp() {
  const now = new Date();
  const y = now.getFullYear();
  const m = String(now.getMonth()+1).padStart(2,'0');
  const d = String(now.getDate()).padStart(2,'0');
  const hh = String(now.getHours()).padStart(2,'0');
  const mm = String(now.getMinutes()).padStart(2,'0');
  const ss = String(now.getSeconds()).padStart(2,'0');
  return { date: `${y}.${m}.${d}`, time: `${hh}:${mm}:${ss} JST` };
}

/* ===== HUD DRAWING — FULL OVERLAY DESIGN ===== */
/* 写真を全面に配置し、その上にフローティングウィンドウを散在させる */

function imgCoords(sourceImage) {
  const sW = sourceImage.width, sH = sourceImage.height;
  const scale = Math.max(W / sW, H / sH);
  return {
    scale,
    dW: sW * scale, dH: sH * scale,
    ox: (W - sW * scale) / 2, oy: (H - sH * scale) / 2
  };
}

function drawCornerBrackets(ctx, x, y, w, h, len, lw, color) {
  ctx.strokeStyle = color; ctx.lineWidth = lw;
  ctx.beginPath(); ctx.moveTo(x, y+len); ctx.lineTo(x, y); ctx.lineTo(x+len, y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x+w-len, y); ctx.lineTo(x+w, y); ctx.lineTo(x+w, y+len); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x, y+h-len); ctx.lineTo(x, y+h); ctx.lineTo(x+len, y+h); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x+w-len, y+h); ctx.lineTo(x+w, y+h); ctx.lineTo(x+w, y+h-len); ctx.stroke();
}

/* --- Panel helper: draws a floating window with title bar --- */
function drawPanel(ctx, x, y, w, h, title) {
  // Background
  ctx.fillStyle = 'rgba(0,0,0,0.72)';
  ctx.fillRect(x, y, w, h);
  // Border
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  ctx.lineWidth = 1;
  ctx.strokeRect(x, y, w, h);
  // Title bar
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.fillRect(x, y, w, 22);
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.beginPath(); ctx.moveTo(x, y+22); ctx.lineTo(x+w, y+22); ctx.stroke();
  // Title text
  ctx.font = '9px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.textAlign = 'left';
  ctx.fillText(title, x + 8, y + 15);
  // Close dot
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  ctx.beginPath(); ctx.arc(x + w - 10, y + 11, 3, 0, Math.PI*2); ctx.fill();
}

function drawBarcode(ctx, x, y, w, h) {
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  let cx = x;
  while (cx < x + w) {
    const bw = Math.random() > 0.5 ? 1 : 3;
    const gap = Math.random() > 0.5 ? 2 : 3;
    ctx.fillRect(cx, y, bw, h);
    cx += bw + gap;
  }
}

function calcAngle(a, b, c) {
  const ab = { x: a.x - b.x, y: a.y - b.y };
  const cb = { x: c.x - b.x, y: c.y - b.y };
  const dot = ab.x * cb.x + ab.y * cb.y;
  const mA = Math.sqrt(ab.x*ab.x + ab.y*ab.y);
  const mC = Math.sqrt(cb.x*cb.x + cb.y*cb.y);
  if (mA === 0 || mC === 0) return 0;
  return Math.round(Math.acos(Math.max(-1, Math.min(1, dot/(mA*mC)))) * 180 / Math.PI);
}

/* ===== LAYER 1: Full-bleed photo with thermal/dark processing ===== */
function drawFullImage(ctx, src) {
  const { ox, oy, dW, dH } = imgCoords(src);
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, W, H);

  // Draw original image first
  ctx.drawImage(src, ox, oy, dW, dH);

  // Apply thermal/dark processing via pixel manipulation
  const imageData = ctx.getImageData(0, 0, W, H);
  const d = imageData.data;
  for (let i = 0; i < d.length; i += 4) {
    const r = d[i], g = d[i+1], b = d[i+2];
    // Luminance
    const lum = (r * 0.299 + g * 0.587 + b * 0.114) / 255;

    // Thermal color mapping: black → deep purple → blue → cyan → yellow → orange → white
    let tr, tg, tb;
    if (lum < 0.12) {
      // Black → very dark purple
      const t = lum / 0.12;
      tr = t * 25; tg = 0; tb = t * 40;
    } else if (lum < 0.28) {
      // Dark purple → deep blue
      const t = (lum - 0.12) / 0.16;
      tr = 25 - t * 15; tg = t * 10; tb = 40 + t * 80;
    } else if (lum < 0.42) {
      // Blue → cyan
      const t = (lum - 0.28) / 0.14;
      tr = 10 + t * 10; tg = 10 + t * 130; tb = 120 + t * 40;
    } else if (lum < 0.55) {
      // Cyan → green-yellow
      const t = (lum - 0.42) / 0.13;
      tr = 20 + t * 180; tg = 140 + t * 60; tb = 160 - t * 140;
    } else if (lum < 0.7) {
      // Yellow → orange
      const t = (lum - 0.55) / 0.15;
      tr = 200 + t * 50; tg = 200 - t * 80; tb = 20 - t * 15;
    } else if (lum < 0.85) {
      // Orange → hot red-orange
      const t = (lum - 0.7) / 0.15;
      tr = 250; tg = 120 - t * 60; tb = 5 + t * 15;
    } else {
      // Hot → near white with warm tint
      const t = (lum - 0.85) / 0.15;
      tr = 250 + t * 5; tg = 60 + t * 160; tb = 20 + t * 180;
    }

    // Pure thermal — no mixing with original
    d[i]   = Math.min(255, tr);
    d[i+1] = Math.min(255, tg);
    d[i+2] = Math.min(255, tb);
  }
  ctx.putImageData(imageData, 0, 0);

  // Darken overall + contrast boost
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.fillRect(0, 0, W, H);

  // Vignette
  const g = ctx.createRadialGradient(W/2, H/2, H*0.18, W/2, H/2, H*0.7);
  g.addColorStop(0, 'rgba(0,0,0,0)');
  g.addColorStop(1, 'rgba(0,0,0,0.6)');
  ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);

  // Subtle grid
  ctx.strokeStyle = 'rgba(255,255,255,0.025)'; ctx.lineWidth = 1;
  for (let x = 0; x < W; x += 90) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for (let y = 0; y < H; y += 90) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
}

/* ===== LAYER 2: Detection overlays on photo ===== */
function drawDetections(ctx, results, src) {
  const { scale, ox, oy } = imgCoords(src);
  const sW = src.width, sH = src.height;

  // --- Object brackets ---
  const subjNames = ['ALPHA','BRAVO','CHARLIE','DELTA','ECHO'];
  let pIdx = 0;
  for (const det of results.objectResults.detections) {
    const b = det.boundingBox;
    const cat = det.categories[0];
    const label = cat.categoryName.toUpperCase();
    const score = Math.round(cat.score * 100);
    const bx = b.originX * scale + ox;
    const by = b.originY * scale + oy;
    const bw = b.width * scale;
    const bh = b.height * scale;
    const bl = Math.min(bw, bh) * 0.2;
    ctx.strokeStyle = 'rgba(255,255,255,0.75)'; ctx.lineWidth = 1.5;
    // TL
    ctx.beginPath(); ctx.moveTo(bx, by+bl); ctx.lineTo(bx, by); ctx.lineTo(bx+bl, by); ctx.stroke();
    // TR
    ctx.beginPath(); ctx.moveTo(bx+bw-bl, by); ctx.lineTo(bx+bw, by); ctx.lineTo(bx+bw, by+bl); ctx.stroke();
    // BL
    ctx.beginPath(); ctx.moveTo(bx, by+bh-bl); ctx.lineTo(bx, by+bh); ctx.lineTo(bx+bl, by+bh); ctx.stroke();
    // BR
    ctx.beginPath(); ctx.moveTo(bx+bw-bl, by+bh); ctx.lineTo(bx+bw, by+bh); ctx.lineTo(bx+bw, by+bh-bl); ctx.stroke();
    // Crosshair
    const ccx = bx+bw/2, ccy = by+bh/2, cr = Math.min(bw,bh)*0.06;
    ctx.strokeStyle = 'rgba(255,255,255,0.25)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(ccx, ccy, cr, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ccx-cr*2,ccy); ctx.lineTo(ccx+cr*2,ccy); ctx.moveTo(ccx,ccy-cr*2); ctx.lineTo(ccx,ccy+cr*2); ctx.stroke();
    // Label
    const isPerson = label === 'PERSON';
    const dLabel = isPerson ? `SUBJ-${subjNames[pIdx]||pIdx}` : label;
    if (isPerson) pIdx++;
    ctx.font = '11px "Share Tech Mono", monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.textAlign = 'left'; ctx.fillText(dLabel, bx+4, by-8);
    ctx.textAlign = 'right'; ctx.fillText(`${score}%`, bx+bw-4, by-8);
    ctx.textAlign = 'left';
  }

  // --- Pose skeleton ---
  for (const lm of results.poseResults.landmarks) {
    const pts = lm.map(p => ({ x: p.x*sW*scale+ox, y: p.y*sH*scale+oy, v: p.visibility }));
    ctx.strokeStyle = 'rgba(255,255,255,0.22)'; ctx.lineWidth = 1;
    for (const [a,b] of POSE_CONNECTIONS) {
      if (a>=pts.length||b>=pts.length) continue;
      if (pts[a].v<0.4||pts[b].v<0.4) continue;
      ctx.beginPath(); ctx.moveTo(pts[a].x, pts[a].y); ctx.lineTo(pts[b].x, pts[b].y); ctx.stroke();
    }
    for (const p of pts) {
      if (p.v<0.4) continue;
      ctx.fillStyle = 'rgba(255,255,255,0.45)';
      ctx.beginPath(); ctx.arc(p.x, p.y, 2.5, 0, Math.PI*2); ctx.fill();
    }
    // Angles
    for (const aj of [{j:14,f:12,t:16},{j:25,f:23,t:27},{j:12,f:11,t:14}]) {
      if (aj.j>=pts.length||aj.f>=pts.length||aj.t>=pts.length) continue;
      if (pts[aj.j].v<0.4||pts[aj.f].v<0.4||pts[aj.t].v<0.4) continue;
      ctx.font = '9px "Share Tech Mono", monospace'; ctx.fillStyle = 'rgba(255,255,255,0.35)';
      ctx.fillText(`${calcAngle(pts[aj.f],pts[aj.j],pts[aj.t])}°`, pts[aj.j].x+6, pts[aj.j].y-6);
    }
  }

  // --- Face targeting ---
  for (const det of results.faceResults.detections) {
    const b = det.boundingBox;
    const fcx = b.originX*scale+ox + b.width*scale/2;
    const fcy = b.originY*scale+oy + b.height*scale/2;
    const r = Math.max(b.width,b.height)*scale*0.55;
    ctx.setLineDash([8,5]); ctx.strokeStyle = 'rgba(255,255,255,0.45)'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(fcx,fcy,r,0,Math.PI*2); ctx.stroke();
    ctx.setLineDash([]); ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(fcx,fcy,r*0.72,0,Math.PI*2); ctx.stroke();
    // Ticks
    ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 2;
    for (let i=0;i<4;i++) {
      const a = i*Math.PI/2;
      ctx.beginPath();
      ctx.moveTo(fcx+Math.cos(a)*(r-7), fcy+Math.sin(a)*(r-7));
      ctx.lineTo(fcx+Math.cos(a)*(r+7), fcy+Math.sin(a)*(r+7));
      ctx.stroke();
    }
    // Small cross
    ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 1;
    const cl = r*0.2;
    ctx.beginPath(); ctx.moveTo(fcx-cl,fcy); ctx.lineTo(fcx+cl,fcy); ctx.moveTo(fcx,fcy-cl); ctx.lineTo(fcx,fcy+cl); ctx.stroke();
  }
}

/* ===== LAYER 3: Floating HUD windows ===== */

function drawHeaderBar(ctx) {
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0, 0, W, 52);
  ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(0,52); ctx.lineTo(W,52); ctx.stroke();

  const ts = formatTimestamp();
  ctx.font = '700 13px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.85)'; ctx.textAlign = 'left';
  ctx.fillText('DARK SCANNER', M, 32);
  ctx.font = '10px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.fillText('CAM-01', 230, 32);
  // REC dot
  ctx.fillStyle = '#ff3333';
  ctx.beginPath(); ctx.arc(310, 28, 3.5, 0, Math.PI*2); ctx.fill();
  ctx.font = '10px "Share Tech Mono", monospace';
  ctx.fillStyle = '#ff3333'; ctx.fillText('REC', 318, 32);
  // Right: date/time
  ctx.textAlign = 'right';
  ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.font = '10px "Share Tech Mono", monospace';
  ctx.fillText(`${ts.date}  ${ts.time}`, W - M, 32);
  ctx.textAlign = 'left';
}

function drawFooterBar(ctx, results, procTime) {
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0, H-48, W, 48);
  ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(0,H-48); ctx.lineTo(W,H-48); ctx.stroke();

  const obj = results.objectResults.detections.length;
  const face = results.faceResults.detections.length;
  const pose = results.poseResults.landmarks.length;
  const person = results.objectResults.detections.filter(d=>d.categories[0].categoryName==='person').length;

  ctx.font = '9px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.35)'; ctx.textAlign = 'left';
  const items = [`OBJ:${obj}`,`PERS:${person}`,`FACE:${face}`,`POSE:${pose}`,`${procTime}MS`];
  let ix = M;
  for (const t of items) {
    ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillText(t, ix, H-20);
    ix += ctx.measureText(t).width + 20;
  }
  ctx.textAlign = 'right';
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.fillText('DARK SCANNER RECON v3.1.0 // UNCLASSIFIED', W-M, H-20);
  ctx.textAlign = 'left';
}

/* --- WINDOW: Subject Data (top-left overlay) --- */
function drawWinSubject(ctx, results) {
  const x = M, y = 70, w = 380, h = 230;
  drawPanel(ctx, x, y, w, h, 'SUBJECT ALPHA // ANALYSIS');

  const persons = results.objectResults.detections.filter(d=>d.categories[0].categoryName==='person');
  const hasPerson = persons.length > 0;
  const conf = hasPerson ? Math.round(persons[0].categories[0].score*100) : randInt(60,95);

  const fields = [
    ['ID', `DSK-${randInt(1000,9999)}`],
    ['STATUS', 'ACTIVE'],
    ['CLASS', hasPerson ? 'CIVILIAN' : 'UNKNOWN'],
    ['THREAT', ['LOW','LOW','LOW','MODERATE'][randInt(0,3)]],
    ['CONFIDENCE', `${conf}%`],
    ['BEARING', `${randInt(0,359)}°`],
    ['HEIGHT EST', `${randInt(155,185)}CM`],
    ['RANGE', `${randFloat(1.0,8.0,1)}M`],
  ];
  ctx.font = '10px "Share Tech Mono", monospace';
  let fy = y + 40;
  for (let i = 0; i < fields.length; i++) {
    const col = i < 4 ? 0 : 1;
    const row = i % 4;
    const fx = x + 12 + col * 190;
    const fiy = fy + row * 22;
    ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillText(fields[i][0]+':', fx, fiy);
    ctx.fillStyle = 'rgba(255,255,255,0.8)'; ctx.fillText(fields[i][1], fx+100, fiy);
  }
  // Biometric bar
  const barY = fy + 100;
  ctx.fillStyle = 'rgba(255,255,255,0.25)'; ctx.font = '8px "Share Tech Mono", monospace';
  ctx.fillText('BIOMETRIC', x+12, barY);
  ctx.fillStyle = 'rgba(255,255,255,0.05)'; ctx.fillRect(x+12, barY+6, 180, 6);
  ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.fillRect(x+12, barY+6, 180*(conf/100), 6);
  ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.fillText(`${conf}%`, x+198, barY+12);
  // Extra line
  ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.font = '8px "Share Tech Mono", monospace';
  ctx.fillText(`GAIT: NORMAL  HR: ${randInt(62,78)} BPM  THERMAL: ${randFloat(36.2,37.1,1)}°C`, x+12, barY+30);
}

/* --- WINDOW: GPS/Telemetry (top-right) --- */
function drawWinTelemetry(ctx) {
  const x = W - M - 340, y = 70, w = 340, h = 130;
  drawPanel(ctx, x, y, w, h, 'TELEMETRY // ENV DATA');
  ctx.font = '9px "Share Tech Mono", monospace';
  const data = [
    `GPS: ${randFloat(35.65,35.70,4)}°N ${randFloat(139.60,139.80,4)}°E`,
    `ALT: ${randInt(10,120)}M  ISO: ${[1600,3200,6400][randInt(0,2)]}  F/${['1.8','2.0','2.8'][randInt(0,2)]}`,
    `TEMP: ${randFloat(18,32,1)}°C  HUM: ${randInt(30,80)}%  WIND: ${randFloat(0,8,1)}M/S`,
    `LUX: ${randInt(200,2000)}  BAND: ${[450,550,700,850][randInt(0,3)]}NM  WB: ${randInt(3200,6500)}K`,
  ];
  for (let i = 0; i < data.length; i++) {
    ctx.fillStyle = 'rgba(255,255,255,0.55)';
    ctx.fillText(data[i], x+10, y+40+i*22);
  }
}

/* --- WINDOW: Signal waveform (mid-right) --- */
function drawWinSignal(ctx) {
  const x = W - M - 300, y = 460, w = 300, h = 200;
  drawPanel(ctx, x, y, w, h, 'SIGNAL INTERCEPT');

  // Waveform
  ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.lineWidth = 1;
  ctx.beginPath();
  for (let i = 0; i < 270; i++) {
    const wx = x+15+i;
    const wy = y+65 + Math.sin(i*0.055)*22 + Math.sin(i*0.14)*10 + (Math.random()-0.5)*5;
    if (i===0) ctx.moveTo(wx,wy); else ctx.lineTo(wx,wy);
  }
  ctx.stroke();
  // Baseline
  ctx.strokeStyle = 'rgba(255,255,255,0.05)';
  ctx.beginPath(); ctx.moveTo(x+15,y+65); ctx.lineTo(x+w-15,y+65); ctx.stroke();

  // Spectrum bars
  for (let i=0; i<34; i++) {
    const bh = Math.random()*35+5;
    ctx.fillStyle = `rgba(255,255,255,${0.1+Math.random()*0.25})`;
    ctx.fillRect(x+15+i*8, y+130-bh, 5, bh);
  }
  // Labels
  ctx.font = '8px "Share Tech Mono", monospace'; ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.fillText(`FREQ: 2.4GHZ  PWR: -${randInt(30,60)}DBM  CH-${randInt(1,48)}`, x+10, y+155);
  ctx.fillText(`ENCRYPT: AES-256  LATENCY: ${randInt(2,18)}MS`, x+10, y+172);
}

/* --- WINDOW: System info (bottom-left) --- */
function drawWinSystem(ctx) {
  const x = M, y = H - 340, w = 350, h = 265;
  drawPanel(ctx, x, y, w, h, 'SYSTEM // CLASSIFICATION');

  ctx.font = '9px "Share Tech Mono", monospace';
  const lines = [
    { l: 'CLASSIFICATION:', v: 'UNCLASSIFIED', c: 'rgba(255,255,255,0.7)' },
    { l: 'SYSTEM:', v: 'DARK SCANNER RECON v3.1.0', c: 'rgba(255,255,255,0.45)' },
    { l: 'MODEL:', v: 'EFFICIENTDET / BLAZEFACE', c: 'rgba(255,255,255,0.45)' },
    { l: 'POSE:', v: 'LANDMARKER-LITE', c: 'rgba(255,255,255,0.45)' },
    { l: 'OPERATOR:', v: '[REDACTED]', c: 'rgba(255,255,255,0.25)' },
    { l: 'AUTH:', v: `${randHex(8)}-${randHex(4)}-${randHex(4)}`, c: 'rgba(255,255,255,0.25)' },
    { l: 'SESSION:', v: `DS-${Date.now().toString(36).toUpperCase()}`, c: 'rgba(255,255,255,0.25)' },
  ];
  for (let i = 0; i < lines.length; i++) {
    ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillText(lines[i].l, x+10, y+40+i*20);
    ctx.fillStyle = lines[i].c; ctx.fillText(lines[i].v, x+130, y+40+i*20);
  }

  // Barcode
  drawBarcode(ctx, x+10, y+190, 200, 32);
  ctx.font = '8px "Share Tech Mono", monospace'; ctx.fillStyle = 'rgba(255,255,255,0.3)';
  const now = new Date();
  ctx.fillText(`DSK-${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}-${String(randInt(1,999)).padStart(3,'0')}`, x+10, y+234);
}

/* --- WINDOW: Biometric/face data (bottom-right) --- */
function drawWinBiometric(ctx, results) {
  const x = W - M - 320, y = H - 300, w = 320, h = 225;
  drawPanel(ctx, x, y, w, h, 'BIOMETRIC // FACE SCAN');

  const hasFace = results.faceResults.detections.length > 0;
  ctx.font = '9px "Share Tech Mono", monospace';

  const fields = [
    ['MATCH', hasFace ? 'NO RECORD' : 'N/A'],
    ['AGE EST', hasFace ? `${randInt(20,45)}` : '--'],
    ['DB SEARCH', hasFace ? `${randInt(40,92)}%` : '0%'],
    ['EXPRESSION', hasFace ? ['NEUTRAL','CALM','FOCUSED'][randInt(0,2)] : '--'],
    ['IRIS', hasFace ? 'SCANNING...' : 'N/A'],
    ['GAIT PATTERN', 'NORMAL'],
    ['HEART RATE', `${randInt(62,82)} BPM`],
    ['RESP RATE', `${randInt(12,20)} RPM`],
    ['SKIN TEMP', `${randFloat(36.1,37.2,1)}°C`],
  ];
  for (let i = 0; i < fields.length; i++) {
    const fy = y + 38 + i * 20;
    ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillText(fields[i][0]+':', x+10, fy);
    ctx.fillStyle = 'rgba(255,255,255,0.65)'; ctx.fillText(fields[i][1], x+130, fy);
  }
}

/* --- WINDOW: Mini data strip (mid-left) --- */
function drawWinMiniData(ctx) {
  const x = M, y = 420, w = 260, h = 110;
  drawPanel(ctx, x, y, w, h, 'ACQUISITION');
  ctx.font = '9px "Share Tech Mono", monospace';
  const data = [
    `SS: 1/${[60,125,250,500][randInt(0,3)]}S`,
    `FL: ${randInt(24,85)}MM  EV: ${randFloat(-2,2,1)}`,
    `GAIN: ${randFloat(0,12,1)}DB  FPS: ${[24,30,60][randInt(0,2)]}`,
  ];
  for (let i=0; i<data.length; i++) {
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.fillText(data[i], x+10, y+40+i*22);
  }
}

/* --- WINDOW: Detection stats (center-bottom overlay) --- */
function drawWinStats(ctx, results, procTime) {
  const w = 420, h = 60;
  const x = (W - w) / 2, y = H - 380;
  drawPanel(ctx, x, y, w, h, 'DETECTION SUMMARY');

  const obj = results.objectResults.detections.length;
  const face = results.faceResults.detections.length;
  const pose = results.poseResults.landmarks.length;
  const pers = results.objectResults.detections.filter(d=>d.categories[0].categoryName==='person').length;

  ctx.font = '10px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.fillText(`OBJ: ${obj}  PERS: ${pers}  FACE: ${face}  POSE: ${pose}  PROC: ${procTime}MS`, x+12, y+45);
}

/* --- WINDOW: QR block (floating, mid area) --- */
function drawWinQR(ctx) {
  const x = W - M - 130, y = 240, w = 130, h = 155;
  drawPanel(ctx, x, y, w, h, 'AUTH TOKEN');
  // QR grid
  const cell = 4, qx = x+15, qy = y+30;
  const cols = 24, rows = 24;
  for (const [cx,cy] of [[0,0],[cols-4,0],[0,rows-4]]) {
    for (let r=0;r<4;r++) for (let c=0;c<4;c++) {
      if (r===0||r===3||c===0||c===3||( r>=1&&r<=2&&c>=1&&c<=2)) {
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.fillRect(qx+(cx+c)*cell, qy+(cy+r)*cell, cell-1, cell-1);
      }
    }
  }
  for (let r=0;r<rows;r++) for (let c=0;c<cols;c++) {
    if (c<4&&r<4) continue; if (c>=cols-4&&r<4) continue; if (c<4&&r>=rows-4) continue;
    if (Math.random()>0.5) {
      ctx.fillStyle = `rgba(255,255,255,${0.12+Math.random()*0.18})`;
      ctx.fillRect(qx+c*cell, qy+r*cell, cell-1, cell-1);
    }
  }
  ctx.font = '7px "Share Tech Mono", monospace'; ctx.fillStyle = 'rgba(255,255,255,0.25)';
  ctx.fillText(randHex(12), x+10, y+140);
}

/* --- WINDOW: Network panel (small, mid-left lower) --- */
function drawWinNetwork(ctx) {
  const x = M, y = 570, w = 220, h = 100;
  drawPanel(ctx, x, y, w, h, 'NET // COMMS');
  ctx.font = '8px "Share Tech Mono", monospace';
  const data = [
    `PROTOCOL: TLS 1.3`,
    `BANDWIDTH: ${randFloat(12,54,1)} MBPS`,
    `PACKET LOSS: ${randFloat(0,0.3,2)}%`,
    `UPLINK: SECURED`,
  ];
  for (let i=0;i<data.length;i++) {
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.fillText(data[i], x+10, y+38+i*15);
  }
}

/* ===== LAYER 4: Global overlay effects ===== */
function drawScanlines(ctx) {
  ctx.fillStyle = 'rgba(0,0,0,0.025)';
  for (let y = 0; y < H; y += 4) ctx.fillRect(0, y, W, 2);
}

/* ===== MASTER RENDER ===== */
async function renderHUD(sourceImage, results) {
  await document.fonts.ready;
  const ctx = hudCtx;
  ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';

  // Layer 1: Full-bleed photo
  drawFullImage(ctx, sourceImage);

  // Layer 2: Detection overlays directly on photo
  drawDetections(ctx, results, sourceImage);

  // Layer 3: Floating HUD windows scattered over photo
  drawHeaderBar(ctx);
  drawWinSubject(ctx, results);
  drawWinTelemetry(ctx);
  drawWinSignal(ctx);
  drawWinMiniData(ctx);
  drawWinNetwork(ctx);
  drawWinQR(ctx);
  drawWinStats(ctx, results, results.procTime);
  drawWinSystem(ctx);
  drawWinBiometric(ctx, results);
  drawFooterBar(ctx, results, results.procTime);

  // Layer 4: Global effects
  drawCornerBrackets(ctx, 6, 6, W-12, H-12, 40, 2, 'rgba(255,255,255,0.2)');
  drawScanlines(ctx);
}

/* ===== PNG SAVE ===== */
function savePNG() {
  hudCanvas.toBlob(async (blob) => {
    const filename = `dark-scanner-${Date.now()}.png`;
    // Try Web Share API for mobile
    if (navigator.share && navigator.canShare) {
      const file = new File([blob], filename, { type: 'image/png' });
      const shareData = { files: [file] };
      if (navigator.canShare(shareData)) {
        try {
          await navigator.share(shareData);
          return;
        } catch (e) {
          // User cancelled or share failed, fall through to download
        }
      }
    }
    // Fallback: download
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  }, 'image/png');
}

/* ===== EVENT HANDLERS ===== */
btnCamera.addEventListener('click', async () => {
  showScreen('camera-screen');
  await startCamera();
});

btnUpload.addEventListener('click', () => {
  fileInput.click();
});

btnGallery.addEventListener('click', () => {
  fileInput.click();
});

fileInput.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  stopCamera();

  const img = new Image();
  img.onload = async () => {
    const results = await analyzeImage(img);
    await renderHUD(img, results);
    showScreen('result-screen');
    URL.revokeObjectURL(img.src);
  };
  img.src = URL.createObjectURL(file);
  e.target.value = '';
});

btnScan.addEventListener('click', async () => {
  const capturedCanvas = captureFrame();
  stopCamera();

  // Convert canvas to image for MediaPipe
  const img = new Image();
  img.onload = async () => {
    const results = await analyzeImage(img);
    await renderHUD(img, results);
    showScreen('result-screen');
  };
  img.src = capturedCanvas.toDataURL();
});

btnFlip.addEventListener('click', async () => {
  currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
  await startCamera();
});

btnBackStart.addEventListener('click', () => {
  stopCamera();
  showScreen('start-screen');
});

btnSave.addEventListener('click', savePNG);

btnNew.addEventListener('click', () => {
  showScreen('start-screen');
});

/* ===== INIT ===== */
initModels();
</script>
</body>
</html>
