<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>DARK SCANNER — Tactical Image Analysis</title>

<!-- OGP -->
<meta property="og:title" content="DARK SCANNER">
<meta property="og:description" content="MediaPipeで人物・顔・ポーズを検出し、CIA/軍事偵察分析風のダークテックHUDで加工する画像ジェネレーター">
<meta property="og:image" content="https://paul13131313.github.io/dark-scanner/ogp.png">
<meta property="og:url" content="https://paul13131313.github.io/dark-scanner/">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">

<!-- Favicon -->
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='12' fill='%23050508'/><circle cx='50' cy='50' r='30' fill='none' stroke='%23ff3c3c' stroke-width='3'/><circle cx='50' cy='50' r='18' fill='none' stroke='%23fff' stroke-width='2' opacity='0.6'/><line x1='50' y1='15' x2='50' y2='85' stroke='%23ff3c3c' stroke-width='1.5' opacity='0.4'/><line x1='15' y1='50' x2='85' y2='50' stroke='%23ff3c3c' stroke-width='1.5' opacity='0.4'/><circle cx='50' cy='50' r='4' fill='%23ff3c3c'/></svg>">

<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000; color: #fff;
    font-family: 'Share Tech Mono', 'SF Mono', 'Fira Code', 'Courier New', monospace;
    overflow: hidden; text-transform: uppercase;
    letter-spacing: 1px;
    -webkit-user-select: none; user-select: none;
    touch-action: manipulation;
  }

  /* ===== START SCREEN ===== */
  .screen { position: fixed; inset: 0; display: none; z-index: 10; }
  .screen.active { display: flex; }

  #start-screen {
    flex-direction: column; align-items: center; justify-content: center;
    background: #000;
  }
  #start-screen::before {
    content: ''; position: absolute; inset: 0;
    background:
      repeating-linear-gradient(0deg, transparent, transparent 79px, rgba(255,255,255,0.03) 79px, rgba(255,255,255,0.03) 80px),
      repeating-linear-gradient(90deg, transparent, transparent 79px, rgba(255,255,255,0.03) 79px, rgba(255,255,255,0.03) 80px);
    pointer-events: none;
  }
  .start-title {
    font-size: 28px; letter-spacing: 8px; font-weight: 700;
    color: rgba(255,255,255,0.9); margin-bottom: 8px; position: relative;
  }
  .start-sub {
    font-size: 10px; letter-spacing: 3px;
    color: rgba(255,255,255,0.3); margin-bottom: 6px;
  }
  .start-version {
    font-size: 9px; letter-spacing: 2px;
    color: rgba(255,255,255,0.15); margin-bottom: 40px;
  }
  #model-status {
    font-size: 10px; letter-spacing: 2px;
    color: rgba(255,255,255,0.4); margin-bottom: 30px;
    min-height: 16px;
  }
  .source-buttons {
    display: flex; flex-direction: column; gap: 12px;
    width: 220px; position: relative;
  }
  .source-btn {
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.7);
    padding: 16px 24px; font-size: 13px; letter-spacing: 3px;
    font-family: inherit; text-transform: uppercase;
    cursor: pointer; transition: all 0.3s;
    display: flex; align-items: center; justify-content: center; gap: 10px;
  }
  .source-btn:hover {
    background: rgba(255,255,255,0.1);
    border-color: rgba(255,255,255,0.4);
    color: #fff;
  }
  .source-btn:disabled {
    opacity: 0.2; cursor: default; pointer-events: none;
  }
  .source-btn .icon { font-size: 16px; }
  .start-footer {
    position: absolute; bottom: 30px;
    font-size: 9px; letter-spacing: 2px;
    color: rgba(255,255,255,0.1);
  }

  /* ===== CAMERA SCREEN ===== */
  #camera-screen {
    flex-direction: column; align-items: center; justify-content: center;
    background: #000;
  }
  #video {
    width: 100%; height: 100%; object-fit: cover;
    position: absolute; inset: 0;
  }
  .camera-hud {
    position: absolute; inset: 0; pointer-events: none;
  }
  .camera-corner {
    position: absolute; width: 30px; height: 30px;
    border-color: rgba(255,255,255,0.4); border-style: solid; border-width: 0;
  }
  .camera-corner.tl { top: 20px; left: 20px; border-top-width: 2px; border-left-width: 2px; }
  .camera-corner.tr { top: 20px; right: 20px; border-top-width: 2px; border-right-width: 2px; }
  .camera-corner.bl { bottom: 100px; left: 20px; border-bottom-width: 2px; border-left-width: 2px; }
  .camera-corner.br { bottom: 100px; right: 20px; border-bottom-width: 2px; border-right-width: 2px; }
  .camera-label {
    position: absolute; top: 30px; left: 50%;
    transform: translateX(-50%);
    font-size: 10px; letter-spacing: 3px;
    color: rgba(255,255,255,0.4);
  }
  .camera-actions {
    position: absolute; bottom: 0; left: 0; right: 0;
    display: flex; align-items: center; justify-content: center;
    padding: 20px; gap: 24px; z-index: 5;
    background: linear-gradient(transparent, rgba(0,0,0,0.8));
  }
  #btn-scan {
    width: 64px; height: 64px; border-radius: 50%;
    background: transparent;
    border: 3px solid rgba(255,255,255,0.8);
    cursor: pointer; position: relative;
    transition: all 0.2s;
  }
  #btn-scan::after {
    content: ''; position: absolute;
    top: 5px; left: 5px; right: 5px; bottom: 5px;
    border-radius: 50%;
    background: #ff3333;
    transition: all 0.2s;
  }
  #btn-scan:active::after { transform: scale(0.9); }
  .cam-ctrl-btn {
    width: 44px; height: 44px; border-radius: 50%;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.7);
    font-size: 18px; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    font-family: inherit;
  }
  #btn-back-start {
    position: absolute; top: 16px; left: 16px;
    width: 40px; height: 40px; border-radius: 50%;
    background: rgba(0,0,0,0.5);
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.7);
    font-size: 18px; cursor: pointer; z-index: 5;
    display: flex; align-items: center; justify-content: center;
    font-family: inherit;
  }

  /* ===== ANALYZING SCREEN ===== */
  #analyzing-screen {
    flex-direction: column; align-items: center; justify-content: center;
    background: #000;
  }
  .analyze-title {
    font-size: 14px; letter-spacing: 4px;
    color: rgba(255,255,255,0.7); margin-bottom: 24px;
  }
  .progress-bar {
    width: 260px; height: 4px;
    background: rgba(255,255,255,0.08); margin-bottom: 16px;
  }
  .progress-fill {
    height: 100%; width: 0%;
    background: #fff; transition: width 0.3s;
  }
  .analyze-detail {
    font-size: 9px; letter-spacing: 2px;
    color: rgba(255,255,255,0.3);
  }

  /* ===== RESULT SCREEN ===== */
  #result-screen {
    flex-direction: column; align-items: center; justify-content: center;
    background: #000; overflow: auto;
    -webkit-overflow-scrolling: touch;
  }
  #result-screen canvas {
    max-width: 100%; max-height: calc(100vh - 80px);
    object-fit: contain;
  }
  .result-actions {
    position: fixed; bottom: 0; left: 0; right: 0;
    display: flex; justify-content: center; gap: 12px;
    padding: 16px;
    background: linear-gradient(transparent, rgba(0,0,0,0.95));
    z-index: 15;
  }
  .result-btn {
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.25);
    color: rgba(255,255,255,0.8);
    padding: 12px 28px; font-size: 12px; letter-spacing: 3px;
    font-family: inherit; text-transform: uppercase;
    cursor: pointer; transition: all 0.3s;
    display: flex; align-items: center; gap: 8px;
  }
  .result-btn:hover {
    background: rgba(255,255,255,0.1);
    border-color: rgba(255,255,255,0.5);
    color: #fff;
  }
  .result-btn .icon { font-size: 14px; }
</style>
</head>
<body>

<!-- START SCREEN -->
<div id="start-screen" class="screen active">
  <div class="start-title">DARK SCANNER</div>
  <div class="start-sub">TACTICAL IMAGE ANALYSIS SYSTEM</div>
  <div class="start-version">RECON v3.1.0</div>
  <div id="model-status">INITIALIZING SYSTEM...</div>
  <div class="source-buttons">
    <button class="source-btn" id="btn-camera" disabled>
      <span class="icon">&#9711;</span> CAMERA
    </button>
    <button class="source-btn" id="btn-upload" disabled>
      <span class="icon">&#9645;</span> UPLOAD
    </button>
  </div>
  <input type="file" id="file-input" accept="image/*,.heic,.heif" hidden>
  <div class="start-footer">SYSTEM: STANDBY</div>
</div>

<!-- CAMERA SCREEN -->
<div id="camera-screen" class="screen">
  <video id="video" autoplay playsinline muted></video>
  <button id="btn-back-start">&larr;</button>
  <div class="camera-hud">
    <div class="camera-corner tl"></div>
    <div class="camera-corner tr"></div>
    <div class="camera-corner bl"></div>
    <div class="camera-corner br"></div>
    <div class="camera-label">SCANNING TARGET...</div>
  </div>
  <div class="camera-actions">
    <button class="cam-ctrl-btn" id="btn-flip">&#8635;</button>
    <button id="btn-scan"></button>
    <button class="cam-ctrl-btn" id="btn-gallery">&#9645;</button>
  </div>
</div>

<!-- ANALYZING SCREEN -->
<div id="analyzing-screen" class="screen">
  <div class="analyze-title">&#9654; ANALYZING...</div>
  <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
  <div class="analyze-detail" id="analyze-detail">INITIALIZING DETECTORS</div>
</div>

<!-- RESULT SCREEN -->
<div id="result-screen" class="screen">
  <canvas id="hud-canvas" width="1080" height="1920"></canvas>
  <div class="result-actions">
    <button class="result-btn" id="btn-save"><span class="icon">&#8681;</span> SAVE</button>
    <button class="result-btn" id="btn-new"><span class="icon">&#9711;</span> NEW</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
<script type="module">
import vision from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js';
const { ObjectDetector, FaceDetector, PoseLandmarker, FilesetResolver } = vision;

/* ===== STATE ===== */
let objectDetector = null;
let faceDetector = null;
let poseLandmarker = null;
let currentFacingMode = 'environment';
let currentStream = null;

/* ===== ELEMENTS ===== */
const startScreen = document.getElementById('start-screen');
const cameraScreen = document.getElementById('camera-screen');
const analyzingScreen = document.getElementById('analyzing-screen');
const resultScreen = document.getElementById('result-screen');
const modelStatus = document.getElementById('model-status');
const btnCamera = document.getElementById('btn-camera');
const btnUpload = document.getElementById('btn-upload');
const btnScan = document.getElementById('btn-scan');
const btnFlip = document.getElementById('btn-flip');
const btnGallery = document.getElementById('btn-gallery');
const btnBackStart = document.getElementById('btn-back-start');
const btnSave = document.getElementById('btn-save');
const btnNew = document.getElementById('btn-new');
const fileInput = document.getElementById('file-input');
const videoEl = document.getElementById('video');
const progressFill = document.getElementById('progress-fill');
const analyzeDetail = document.getElementById('analyze-detail');
const hudCanvas = document.getElementById('hud-canvas');
const hudCtx = hudCanvas.getContext('2d');

/* ===== CONSTANTS ===== */
const W = 1080;
const H = 1920;
const M = 30;

/* ===== FINGERPRINT IMAGE PRELOAD ===== */
// Load fingerprint.jpg, invert colors (black→white), make background transparent
let fingerprintCanvas = null;
{
  const fpImg = new Image();
  fpImg.onload = () => {
    const c = document.createElement('canvas');
    c.width = fpImg.naturalWidth;
    c.height = fpImg.naturalHeight;
    const cx = c.getContext('2d');
    cx.drawImage(fpImg, 0, 0);
    const imgData = cx.getImageData(0, 0, c.width, c.height);
    const d = imgData.data;
    for (let i = 0; i < d.length; i += 4) {
      // Original: black fingerprint on white background
      // Luminance of the pixel
      const lum = d[i] * 0.299 + d[i+1] * 0.587 + d[i+2] * 0.114;
      // Invert: dark pixels become bright white, light pixels become transparent
      const inverted = 255 - lum;
      // Alpha: dark original = opaque white, light original = transparent
      const alpha = Math.min(255, inverted * 1.8);
      d[i] = 255;      // R: white
      d[i+1] = 255;    // G: white
      d[i+2] = 255;    // B: white
      d[i+3] = Math.max(0, alpha); // A: based on original darkness
    }
    cx.putImageData(imgData, 0, 0);
    fingerprintCanvas = c;
  };
  fpImg.src = 'public/fingerprint.jpg';
}

/* ===== POSE CONNECTIONS ===== */
const POSE_CONNECTIONS = [
  [0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],
  [9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],
  [17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],
  [11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],
  [27,29],[28,30],[29,31],[30,32],[27,31],[28,32]
];

/* ===== SCREEN MANAGEMENT ===== */
function showScreen(id) {
  [startScreen, cameraScreen, analyzingScreen, resultScreen].forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

/* ===== MODEL INITIALIZATION ===== */
async function initModels() {
  try {
    modelStatus.textContent = 'LOADING VISION RUNTIME...';
    const filesetResolver = await FilesetResolver.forVisionTasks(
      'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm'
    );

    modelStatus.textContent = 'LOADING MODEL 1/3 — OBJECT DETECTOR...';
    objectDetector = await ObjectDetector.createFromOptions(filesetResolver, {
      baseOptions: {
        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/object_detector/efficientdet_lite0/float16/1/efficientdet_lite0.tflite',
        delegate: 'GPU'
      },
      maxResults: 10,
      scoreThreshold: 0.3,
      runningMode: 'IMAGE'
    });

    modelStatus.textContent = 'LOADING MODEL 2/3 — FACE DETECTOR...';
    faceDetector = await FaceDetector.createFromOptions(filesetResolver, {
      baseOptions: {
        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_detector/blaze_face_short_range/float16/1/blaze_face_short_range.tflite',
        delegate: 'GPU'
      },
      runningMode: 'IMAGE'
    });

    modelStatus.textContent = 'LOADING MODEL 3/3 — POSE LANDMARKER...';
    poseLandmarker = await PoseLandmarker.createFromOptions(filesetResolver, {
      baseOptions: {
        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task',
        delegate: 'GPU'
      },
      runningMode: 'IMAGE',
      numPoses: 5
    });

    modelStatus.textContent = 'ALL SYSTEMS OPERATIONAL';
    btnCamera.disabled = false;
    btnUpload.disabled = false;
    document.querySelector('.start-footer').textContent = 'SYSTEM: READY';
  } catch (e) {
    console.error('Model init error:', e);
    modelStatus.textContent = 'ERROR: ' + e.message;
  }
}

/* ===== CAMERA ===== */
async function startCamera() {
  try {
    if (currentStream) {
      currentStream.getTracks().forEach(t => t.stop());
    }
    currentStream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: currentFacingMode, width: { ideal: 1080 }, height: { ideal: 1920 } }
    });
    videoEl.srcObject = currentStream;
    await new Promise(r => { videoEl.onloadeddata = r; });
  } catch (e) {
    console.error('Camera error:', e);
    alert('CAMERA ACCESS DENIED');
    showScreen('start-screen');
  }
}

function stopCamera() {
  if (currentStream) {
    currentStream.getTracks().forEach(t => t.stop());
    currentStream = null;
  }
}

function captureFrame() {
  const c = document.createElement('canvas');
  c.width = videoEl.videoWidth;
  c.height = videoEl.videoHeight;
  const cx = c.getContext('2d');
  cx.drawImage(videoEl, 0, 0);
  return c;
}

/* ===== DETECTION ===== */
async function analyzeImage(imageSource) {
  showScreen('analyzing-screen');
  progressFill.style.width = '0%';

  analyzeDetail.textContent = 'RUNNING OBJECT DETECTION...';
  progressFill.style.width = '10%';
  await new Promise(r => setTimeout(r, 50));
  const t0 = performance.now();
  const objectResults = objectDetector.detect(imageSource);
  progressFill.style.width = '33%';

  analyzeDetail.textContent = 'RUNNING FACE DETECTION...';
  await new Promise(r => setTimeout(r, 50));
  const faceResults = faceDetector.detect(imageSource);
  progressFill.style.width = '66%';

  analyzeDetail.textContent = 'RUNNING POSE ESTIMATION...';
  await new Promise(r => setTimeout(r, 50));
  const poseResults = poseLandmarker.detect(imageSource);
  progressFill.style.width = '90%';

  const procTime = Math.round(performance.now() - t0);

  analyzeDetail.textContent = 'GENERATING HUD OVERLAY...';
  progressFill.style.width = '100%';
  await new Promise(r => setTimeout(r, 200));

  return { objectResults, faceResults, poseResults, procTime };
}

/* ===== FAKE DATA GENERATORS ===== */
function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function randFloat(min, max, dec) { return (Math.random() * (max - min) + min).toFixed(dec); }
function randHex(len) { return Array.from({length: len}, () => Math.floor(Math.random() * 16).toString(16)).join('').toUpperCase(); }

function formatTimestamp() {
  const now = new Date();
  const y = now.getFullYear();
  const m = String(now.getMonth()+1).padStart(2,'0');
  const d = String(now.getDate()).padStart(2,'0');
  const hh = String(now.getHours()).padStart(2,'0');
  const mm = String(now.getMinutes()).padStart(2,'0');
  const ss = String(now.getSeconds()).padStart(2,'0');
  return { date: `${y}.${m}.${d}`, time: `${hh}:${mm}:${ss} JST` };
}

/* =========================================================
   HUD DRAWING — V5: PHOTO-DOMINANT OVERLAY
   - Photo fills nearly the entire canvas (edge-to-edge)
   - ALL elements overlay ON TOP of the photo
   - Extreme text size contrast (140px ↔ 8px)
   - Clean data panels with semi-transparent backgrounds
   - Monochrome, high contrast
   ========================================================= */

function calcAngle(a, b, c) {
  const ab = { x: a.x - b.x, y: a.y - b.y };
  const cb = { x: c.x - b.x, y: c.y - b.y };
  const dot = ab.x * cb.x + ab.y * cb.y;
  const mA = Math.sqrt(ab.x*ab.x + ab.y*ab.y);
  const mC = Math.sqrt(cb.x*cb.x + cb.y*cb.y);
  if (mA === 0 || mC === 0) return 0;
  return Math.round(Math.acos(Math.max(-1, Math.min(1, dot/(mA*mC)))) * 180 / Math.PI);
}

/* --- Helpers --- */
function drawCornerBrackets(ctx, x, y, w, h, len, lw, color) {
  ctx.strokeStyle = color; ctx.lineWidth = lw;
  ctx.beginPath(); ctx.moveTo(x, y+len); ctx.lineTo(x, y); ctx.lineTo(x+len, y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x+w-len, y); ctx.lineTo(x+w, y); ctx.lineTo(x+w, y+len); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x, y+h-len); ctx.lineTo(x, y+h); ctx.lineTo(x+len, y+h); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x+w-len, y+h); ctx.lineTo(x+w, y+h); ctx.lineTo(x+w, y+h-len); ctx.stroke();
}

function drawBarcode(ctx, x, y, w, h) {
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  let cx = x;
  while (cx < x + w) {
    const bw = Math.random() > 0.5 ? 1 : 3;
    const gap = Math.random() > 0.5 ? 2 : 3;
    ctx.fillRect(cx, y, bw, h);
    cx += bw + gap;
  }
}

function drawQRBlock(ctx, qx, qy, cellSize, cols, rows) {
  for (const [cx,cy] of [[0,0],[cols-5,0],[0,rows-5]]) {
    for (let r=0;r<5;r++) for (let c=0;c<5;c++) {
      if (r===0||r===4||c===0||c===4||(r>=1&&r<=3&&c>=1&&c<=3)) {
        ctx.fillStyle = 'rgba(255,255,255,0.55)';
        ctx.fillRect(qx+(cx+c)*cellSize, qy+(cy+r)*cellSize, cellSize-1, cellSize-1);
      }
    }
  }
  for (let r=0;r<rows;r++) for (let c=0;c<cols;c++) {
    if (c<5&&r<5) continue; if (c>=cols-5&&r<5) continue; if (c<5&&r>=rows-5) continue;
    if (Math.random()>0.5) {
      ctx.fillStyle = `rgba(255,255,255,${0.1+Math.random()*0.25})`;
      ctx.fillRect(qx+c*cellSize, qy+r*cellSize, cellSize-1, cellSize-1);
    }
  }
}

/* Draw a clean data panel with semi-transparent BG */
function drawPanel(ctx, x, y, w, h, opts = {}) {
  ctx.fillStyle = opts.bg || 'rgba(0,0,0,0.82)';
  ctx.fillRect(x, y, w, h);
  if (opts.border !== false) {
    ctx.strokeStyle = opts.borderColor || 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(x, y, w, h);
  }
}

/* ===== PHOTO — nearly full canvas ===== */
const PHOTO_X = 0;
const PHOTO_Y = 0;
const PHOTO_W = W;    // 1080
const PHOTO_H = H;    // 1920

/* ===== LAYER 1: Photo fills entire canvas (monochrome) ===== */
function drawPhoto(ctx, src) {
  const sW = src.width, sH = src.height;
  const scale = Math.max(PHOTO_W / sW, PHOTO_H / sH);
  const dW = sW * scale, dH = sH * scale;
  const ox = (PHOTO_W - dW) / 2;
  const oy = (PHOTO_H - dH) / 2;

  ctx.drawImage(src, ox, oy, dW, dH);

  // Monochrome + high contrast
  const imageData = ctx.getImageData(0, 0, W, H);
  const d = imageData.data;
  for (let i = 0; i < d.length; i += 4) {
    let lum = (d[i] * 0.299 + d[i+1] * 0.587 + d[i+2] * 0.114);
    lum = lum < 80 ? lum * 0.4 : Math.min(255, lum * 1.2 + 10);
    d[i] = d[i+1] = d[i+2] = lum;
  }
  ctx.putImageData(imageData, 0, 0);

  // Top gradient fade (for header readability)
  const gTop = ctx.createLinearGradient(0, 0, 0, 320);
  gTop.addColorStop(0, 'rgba(0,0,0,0.7)');
  gTop.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = gTop; ctx.fillRect(0, 0, W, 320);

  // Bottom gradient fade (for footer readability)
  const gBot = ctx.createLinearGradient(0, H - 500, 0, H);
  gBot.addColorStop(0, 'rgba(0,0,0,0)');
  gBot.addColorStop(1, 'rgba(0,0,0,0.8)');
  ctx.fillStyle = gBot; ctx.fillRect(0, H - 500, W, 500);

  // Subtle vignette
  const gVig = ctx.createRadialGradient(W/2, H*0.4, W*0.2, W/2, H*0.4, W*0.8);
  gVig.addColorStop(0, 'rgba(0,0,0,0)');
  gVig.addColorStop(1, 'rgba(0,0,0,0.35)');
  ctx.fillStyle = gVig; ctx.fillRect(0, 0, W, H);
}

/* ===== LAYER 2: X-cross + grid lines (over photo) ===== */
function drawCrossLines(ctx) {
  // Diagonal X — bolder
  ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(W, H); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(W, 0); ctx.lineTo(0, H); ctx.stroke();

  // Center cross
  ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(0, H/2); ctx.lineTo(W, H/2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(W/2, 0); ctx.lineTo(W/2, H); ctx.stroke();

  // Grid — slightly bolder
  ctx.strokeStyle = 'rgba(255,255,255,0.03)'; ctx.lineWidth = 1;
  for (let x = 0; x < W; x += 60) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for (let y = 0; y < H; y += 60) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

  // Corner frame markers — new bold element
  const cm = 40;
  ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.lineWidth = 3;
  // Top-left
  ctx.beginPath(); ctx.moveTo(M, M+cm); ctx.lineTo(M, M); ctx.lineTo(M+cm, M); ctx.stroke();
  // Top-right
  ctx.beginPath(); ctx.moveTo(W-M-cm, M); ctx.lineTo(W-M, M); ctx.lineTo(W-M, M+cm); ctx.stroke();
  // Bottom-left
  ctx.beginPath(); ctx.moveTo(M, H-M-cm); ctx.lineTo(M, H-M); ctx.lineTo(M+cm, H-M); ctx.stroke();
  // Bottom-right
  ctx.beginPath(); ctx.moveTo(W-M-cm, H-M); ctx.lineTo(W-M, H-M); ctx.lineTo(W-M, H-M-cm); ctx.stroke();
}

/* ===== LAYER 3: Detection overlays (on full photo) ===== */
function drawDetections(ctx, results, src) {
  const sW = src.width, sH = src.height;
  const scale = Math.max(W / sW, H / sH);
  const baseOX = (W - sW * scale) / 2;
  const baseOY = (H - sH * scale) / 2;

  // --- Object brackets ---
  const subjNames = ['ALPHA','BRAVO','CHARLIE','DELTA','ECHO'];
  let pIdx = 0;
  for (const det of results.objectResults.detections) {
    const b = det.boundingBox;
    const cat = det.categories[0];
    const label = cat.categoryName.toUpperCase();
    const score = Math.round(cat.score * 100);
    const bx = b.originX * scale + baseOX;
    const by = b.originY * scale + baseOY;
    const bw = b.width * scale;
    const bh = b.height * scale;
    const bl = Math.min(bw, bh) * 0.12;
    ctx.strokeStyle = 'rgba(255,255,255,0.75)'; ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.moveTo(bx, by+bl); ctx.lineTo(bx, by); ctx.lineTo(bx+bl, by); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(bx+bw-bl, by); ctx.lineTo(bx+bw, by); ctx.lineTo(bx+bw, by+bl); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(bx, by+bh-bl); ctx.lineTo(bx, by+bh); ctx.lineTo(bx+bl, by+bh); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(bx+bw-bl, by+bh); ctx.lineTo(bx+bw, by+bh); ctx.lineTo(bx+bw, by+bh-bl); ctx.stroke();
    const isPerson = label === 'PERSON';
    const dLabel = isPerson ? `SUBJ-${subjNames[pIdx]||pIdx}` : label;
    if (isPerson) pIdx++;
    ctx.font = '900 14px "Share Tech Mono", monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.textAlign = 'left'; ctx.fillText(dLabel, bx+4, by-6);
    ctx.textAlign = 'right'; ctx.fillText(`${score}%`, bx+bw-4, by-6);
    ctx.textAlign = 'left';
  }

  // --- Pose skeleton ---
  for (const lm of results.poseResults.landmarks) {
    const pts = lm.map(p => ({ x: p.x*sW*scale+baseOX, y: p.y*sH*scale+baseOY, v: p.visibility }));
    ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 2;
    for (const [a,b] of POSE_CONNECTIONS) {
      if (a>=pts.length||b>=pts.length) continue;
      if (pts[a].v<0.4||pts[b].v<0.4) continue;
      ctx.beginPath(); ctx.moveTo(pts[a].x, pts[a].y); ctx.lineTo(pts[b].x, pts[b].y); ctx.stroke();
    }
    for (const p of pts) {
      if (p.v<0.4) continue;
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.beginPath(); ctx.arc(p.x, p.y, 3.5, 0, Math.PI*2); ctx.fill();
    }
  }

  // --- Face targeting ---
  for (const det of results.faceResults.detections) {
    const b = det.boundingBox;
    const fcx = b.originX*scale+baseOX + b.width*scale/2;
    const fcy = b.originY*scale+baseOY + b.height*scale/2;
    const r = Math.max(b.width,b.height)*scale*0.5;
    ctx.setLineDash([10,6]); ctx.strokeStyle = 'rgba(255,255,255,0.55)'; ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.arc(fcx,fcy,r,0,Math.PI*2); ctx.stroke();
    ctx.setLineDash([]);
    ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 3;
    for (let i=0;i<4;i++) {
      const a = i*Math.PI/2;
      ctx.beginPath();
      ctx.moveTo(fcx+Math.cos(a)*(r-6), fcy+Math.sin(a)*(r-6));
      ctx.lineTo(fcx+Math.cos(a)*(r+6), fcy+Math.sin(a)*(r+6));
      ctx.stroke();
    }
  }
}

/* ===== LAYER 4: GIANT typography (overlaid on photo) ===== */
function drawGiantText(ctx) {
  // "RECON" — MASSIVE top-right
  ctx.font = '900 180px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.textAlign = 'right';
  ctx.fillText('RECON', W - 10, 200);
  // ".XX" — big number below
  ctx.font = '900 100px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.30)';
  ctx.fillText(`.${String(randInt(1,12)).padStart(2,'0')}`, W - 10, 290);
  ctx.textAlign = 'left';

  // "SIGNAL INTERCEPT" — huge vertical watermark, center-left
  ctx.save();
  ctx.translate(90, H * 0.58);
  ctx.rotate(-Math.PI / 2);
  ctx.font = '900 130px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.05)';
  ctx.textAlign = 'center';
  ctx.fillText('SIGNAL INTERCEPT', 0, 0);
  ctx.restore();

  // "DETECT" — huge horizontal text across the mid-right area
  ctx.font = '900 200px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  ctx.textAlign = 'right';
  ctx.fillText('DETECT', W + 20, H * 0.52);
  ctx.textAlign = 'left';

  // ===== FULL-WIDTH BOLD WHITE TEXT — photo lower area =====
  // Scale text using canvas transform to GUARANTEE full-width fit
  function drawFullWidthText(ctx, text, y, alpha) {
    const pad = 20;
    const targetW = W - pad * 2;
    ctx.save();
    // Measure at a fixed size, then scale horizontally to fill width
    const baseSize = 140;
    ctx.font = `900 ${baseSize}px "Share Tech Mono", monospace`;
    const measured = ctx.measureText(text).width;
    const scaleX = targetW / measured;
    ctx.translate(pad, y);
    ctx.scale(scaleX, 1);
    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    ctx.fillText(text, 0, 0);
    ctx.restore();
  }

  // Line 1: fills ENTIRE width edge-to-edge
  drawFullWidthText(ctx, 'SUBJECT IDENTIFIED', H - 430, 0.22);
  // Line 2: fills ENTIRE width edge-to-edge
  drawFullWidthText(ctx, 'THREAT LEVEL: ACTIVE', H - 300, 0.13);

  // "TOP SECRET" — LARGE red stamp, mid-screen
  ctx.font = '900 56px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,60,60,0.12)';
  ctx.fillText('TOP SECRET', 24, H * 0.46);

  // "EYES ONLY" — right side, medium-large
  ctx.font = '900 42px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  ctx.textAlign = 'right';
  ctx.fillText('EYES ONLY', W - 20, H * 0.70);
  ctx.textAlign = 'left';

  // "TARGET ACQUIRED" — bottom-left, medium
  ctx.font = '900 36px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,60,60,0.10)';
  ctx.fillText('TARGET ACQUIRED', 24, H * 0.58);

  // Hex code — medium
  ctx.font = '700 28px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.07)';
  ctx.fillText(`0x${randHex(16)}`, 24, H * 0.64);

  // "NO UNAUTHORIZED ACCESS" — watermark, bottom-right
  ctx.font = '700 22px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.05)';
  ctx.textAlign = 'right';
  ctx.fillText('NO UNAUTHORIZED ACCESS', W - 24, H * 0.78);
  ctx.textAlign = 'left';

  // ===== FULL-WIDTH DIGITAL ALERT STRIPE =====
  // White readable text across photo lower-mid area
  const alertY = H * 0.84;
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.fillRect(0, alertY - 22, W, 36);
  ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(0, alertY - 22); ctx.lineTo(W, alertY - 22); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0, alertY + 14); ctx.lineTo(W, alertY + 14); ctx.stroke();
  ctx.font = '900 24px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.30)';
  ctx.textAlign = 'center';
  ctx.fillText('■  CLASSIFIED  //  DO  NOT  DISTRIBUTE  ■', W / 2, alertY + 4);
  ctx.textAlign = 'left';

  // Repeating "CONFIDENTIAL" ticker tape
  ctx.font = '900 14px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  const tickerY = H * 0.88;
  let tickerX = 0;
  while (tickerX < W) {
    ctx.fillText('CONFIDENTIAL', tickerX, tickerY);
    tickerX += 160;
  }
}

/* ===== LAYER 5: Top header panel (over photo) ===== */
function drawHeaderPanel(ctx) {
  drawPanel(ctx, 0, 0, W, 58, { bg: 'rgba(0,0,0,0.88)' });
  const ts = formatTimestamp();
  ctx.font = '900 22px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.textAlign = 'left';
  ctx.fillText('DARK SCANNER', 20, 38);

  // REC indicator — bigger
  ctx.fillStyle = '#ff3333';
  ctx.beginPath(); ctx.arc(280, 33, 6, 0, Math.PI*2); ctx.fill();
  ctx.font = '700 13px "Share Tech Mono", monospace';
  ctx.fillStyle = '#ff3333'; ctx.fillText('REC', 292, 38);

  ctx.font = '700 11px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.45)';
  ctx.fillText('CAM-01 // RECON v3.1', 340, 38);

  // Red separator line at bottom of header
  ctx.fillStyle = 'rgba(255,60,60,0.4)';
  ctx.fillRect(0, 56, W, 2);

  ctx.textAlign = 'right';
  ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.font = '700 13px "Share Tech Mono", monospace';
  ctx.fillText(`${ts.date}  ${ts.time}`, W - 20, 38);
  ctx.textAlign = 'left';
}

/* ===== LAYER 6: Left data panel (over photo, semi-transparent) ===== */
function drawLeftPanel(ctx, results) {
  const px = 16, py = 68, pw = 280, ph = 680;
  drawPanel(ctx, px, py, pw, ph, { bg: 'rgba(0,0,0,0.88)' });
  // Red accent line on left edge — thicker
  ctx.fillStyle = 'rgba(255,60,60,0.7)';
  ctx.fillRect(px, py, 3, ph);

  let y = py + 22;
  const x = px + 16;

  // Section: ORGANIZATION
  ctx.font = '700 9px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('ORGANIZATION  組織', x, y);
  ctx.font = '700 14px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.fillText('DSK.SYSTEMS', x, y + 18);
  y += 42;

  // Section: COLLECTION
  ctx.font = '700 9px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('COLLECTION  収集', x, y);
  ctx.font = '700 14px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.fillText('RECON-3-SURVEILLANCE', x, y + 18);
  y += 42;

  // Section: SESSION
  ctx.font = '700 9px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('SESSION  区分', x, y);
  ctx.font = '700 14px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  const ts = formatTimestamp();
  ctx.fillText(ts.date + ' // ' + ts.time, x, y + 18);
  y += 42;

  // Separator — thicker, red
  ctx.strokeStyle = 'rgba(255,60,60,0.3)'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + pw - 32, y); ctx.stroke();
  y += 16;

  // Section: CODENAME with icon
  ctx.font = '700 9px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('CODENAME  識別', x, y);
  y += 18;
  ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(x+10, y+2, 8, 0, Math.PI*2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x+10, y-6); ctx.lineTo(x+10, y+10); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x+2, y+2); ctx.lineTo(x+18, y+2); ctx.stroke();
  ctx.font = '900 16px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.fillText(`DSK-RN${randInt(1,9)}-SC${randInt(10,99)}-BK`, x + 26, y + 6);
  y += 30;

  // Separator
  ctx.strokeStyle = 'rgba(255,60,60,0.3)'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + pw - 32, y); ctx.stroke();
  y += 18;

  // === THREAT LEVEL — BIG ===
  const threatLevels = ['LOW','MODERATE','ELEVATED','HIGH'];
  const threatIdx = randInt(0,3);
  const threat = threatLevels[threatIdx];
  ctx.font = '700 9px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('THREAT LEVEL  脅威', x, y);
  y += 6;
  ctx.font = '900 38px "Share Tech Mono", monospace';
  ctx.fillStyle = threatIdx >= 2 ? 'rgba(255,60,60,0.95)' : 'rgba(255,255,255,0.9)';
  ctx.fillText(threat, x, y + 32);
  y += 42;
  // Confidence bar — thicker
  const conf = randInt(40, 98);
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.fillRect(x, y, pw - 32, 8);
  ctx.fillStyle = threatIdx >= 2 ? 'rgba(255,60,60,0.7)' : 'rgba(255,255,255,0.5)';
  ctx.fillRect(x, y, (pw - 32) * conf / 100, 8);
  ctx.font = '700 9px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText(`${conf}%`, x + pw - 56, y + 7);
  y += 24;

  // Subject data rows — bigger
  const persons = results.objectResults.detections.filter(d=>d.categories[0].categoryName==='person');
  const hasFace = results.faceResults.detections.length > 0;
  const fields = [
    ['STATUS', 'ACTIVE'],
    ['CLASS', persons.length > 0 ? 'CIVILIAN' : 'UNKNOWN'],
    ['HR', `${randInt(62,82)} BPM`],
    ['THERMAL', `${randFloat(36.1,37.2,1)}°C`],
    ['BIOMETRIC', hasFace ? 'SCANNING' : 'N/A'],
    ['BEARING', `${randInt(0,359)}°`],
    ['RANGE', `${randFloat(1.0,8.0,1)}M`],
    ['PROTOCOL', 'AES-256'],
    ['SIGNAL', `${randInt(-60,-20)}dBm`],
  ];
  for (const f of fields) {
    ctx.font = '700 9px "Share Tech Mono", monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.45)'; ctx.fillText(f[0], x, y);
    ctx.font = '700 13px "Share Tech Mono", monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.85)'; ctx.fillText(f[1], x + 80, y);
    y += 20;
  }

  // === Heart rate waveform (bigger graph) ===
  y += 10;
  ctx.font = '700 9px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,60,60,0.7)';
  ctx.fillText('HR WAVEFORM', x, y);
  y += 10;
  ctx.strokeStyle = 'rgba(255,60,60,0.6)'; ctx.lineWidth = 2.5;
  ctx.beginPath();
  for (let i = 0; i < pw - 32; i++) {
    const wx = x + i;
    const phase = (i / (pw - 32)) * Math.PI * 6;
    let val = Math.sin(phase) * 4;
    if (i % 38 < 4) val = -20 + Math.random() * 40; // QRS spike
    const wy = y + 22 + val;
    if (i===0) ctx.moveTo(wx,wy); else ctx.lineTo(wx,wy);
  }
  ctx.stroke();

  // === Mini barcode at bottom of left panel ===
  y += 50;
  drawBarcode(ctx, x, y, pw - 40, 16);
}

/* ===== Thermal colormap for sub-images ===== */
function thermalColor(lum) {
  let r, g, b;
  if (lum < 0.2) {
    const t = lum / 0.2;
    r = 0; g = 0; b = Math.round(40 + t * 140);
  } else if (lum < 0.4) {
    const t = (lum - 0.2) / 0.2;
    r = 0; g = Math.round(t * 160); b = Math.round(180 - t * 80);
  } else if (lum < 0.6) {
    const t = (lum - 0.4) / 0.2;
    r = Math.round(t * 220); g = Math.round(160 + t * 60); b = Math.round(100 - t * 100);
  } else if (lum < 0.8) {
    const t = (lum - 0.6) / 0.2;
    r = Math.round(220 + t * 35); g = Math.round(220 - t * 140); b = 0;
  } else {
    const t = (lum - 0.8) / 0.2;
    r = 255; g = Math.round(80 + t * 175); b = Math.round(t * 200);
  }
  return [r, g, b];
}

function applyThermalFilter(ctx, x, y, w, h) {
  const imageData = ctx.getImageData(x, y, w, h);
  const d = imageData.data;
  // Block-pixelate first, then apply thermal colormap
  const blockSize = 6;
  for (let by = 0; by < h; by += blockSize) {
    for (let bx = 0; bx < w; bx += blockSize) {
      // Average luminance in block
      let lumSum = 0, count = 0;
      for (let dy = 0; dy < blockSize && by + dy < h; dy++) {
        for (let dx = 0; dx < blockSize && bx + dx < w; dx++) {
          const idx = ((by + dy) * w + (bx + dx)) * 4;
          lumSum += (d[idx] * 0.299 + d[idx+1] * 0.587 + d[idx+2] * 0.114) / 255;
          count++;
        }
      }
      const avgLum = lumSum / count;
      // Quantize to 8 levels for harsh thermal look
      const qLum = Math.round(avgLum * 8) / 8;
      const [r, g, b] = thermalColor(qLum);
      // Fill entire block with thermal color
      for (let dy = 0; dy < blockSize && by + dy < h; dy++) {
        for (let dx = 0; dx < blockSize && bx + dx < w; dx++) {
          const idx = ((by + dy) * w + (bx + dx)) * 4;
          d[idx] = r; d[idx+1] = g; d[idx+2] = b;
        }
      }
    }
  }
  ctx.putImageData(imageData, x, y);
}

/* ===== LAYER 7: Right side panels (over photo) ===== */
function drawRightPanels(ctx, src, results) {
  // Sub-image panel 1 — THERMAL IMAGING (face/upper body)
  const subX = W - 200, subY = 300, subW = 170, subH = 190;
  drawPanel(ctx, subX - 4, subY - 16, subW + 8, subH + 20, { bg: 'rgba(0,0,0,0.75)', borderColor: 'rgba(255,60,60,0.35)' });
  ctx.font = '700 9px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,60,60,0.8)';
  ctx.fillText('■  THERMAL_SCAN', subX, subY - 4);

  ctx.save();
  ctx.beginPath(); ctx.rect(subX, subY, subW, subH); ctx.clip();
  const crScale = Math.max(subW / src.width, subH / (src.height * 0.35));
  ctx.drawImage(src, 0, 0, src.width, src.height * 0.35, subX, subY, src.width * crScale, src.height * 0.35 * crScale);
  ctx.restore();
  // Apply thermal colormap
  applyThermalFilter(ctx, subX, subY, subW, subH);
  // Thermal temp label — bigger
  ctx.font = '900 20px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,120,60,0.9)';
  ctx.fillText(`${randFloat(36.2,37.4,1)}°C`, subX + 4, subY + subH - 8);
  // Red border accent — thicker
  ctx.strokeStyle = 'rgba(255,60,60,0.45)'; ctx.lineWidth = 2;
  ctx.strokeRect(subX, subY, subW, subH);

  // Sub-image panel 2 — BIOMETRIC SCAN (mid body, also thermal)
  const sub2Y = subY + subH + 26;
  drawPanel(ctx, subX - 4, sub2Y - 16, subW + 8, subH + 20, { bg: 'rgba(0,0,0,0.75)', borderColor: 'rgba(255,60,60,0.35)' });
  ctx.font = '700 9px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,60,60,0.8)';
  ctx.fillText('■  BIOMETRIC_IR', subX, sub2Y - 4);

  ctx.save();
  ctx.beginPath(); ctx.rect(subX, sub2Y, subW, subH); ctx.clip();
  const cr2Scale = Math.max(subW / src.width, subH / (src.height * 0.35));
  ctx.drawImage(src, 0, src.height*0.3, src.width, src.height*0.35, subX, sub2Y, src.width*cr2Scale, src.height*0.35*cr2Scale);
  ctx.restore();
  applyThermalFilter(ctx, subX, sub2Y, subW, subH);
  // Temp label — bigger
  ctx.font = '900 20px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,120,60,0.9)';
  ctx.fillText(`${randFloat(35.8,36.8,1)}°C`, subX + 4, sub2Y + subH - 8);
  ctx.strokeStyle = 'rgba(255,60,60,0.45)'; ctx.lineWidth = 2;
  ctx.strokeRect(subX, sub2Y, subW, subH);

  // Right data panel (signal + specs) — bigger, bolder
  const rpX = W - 260, rpY = sub2Y + subH + 30, rpW = 242, rpH = 340;
  drawPanel(ctx, rpX, rpY, rpW, rpH, { bg: 'rgba(0,0,0,0.85)', borderColor: 'rgba(255,60,60,0.25)' });
  // Red accent line top — thicker
  ctx.fillStyle = 'rgba(255,60,60,0.6)';
  ctx.fillRect(rpX, rpY, rpW, 3);

  let ry = rpY + 20;
  ctx.font = '700 10px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('SIGNAL  信号', rpX + 14, ry);
  ry += 16;

  // Big freq number — bolder
  ctx.font = '900 52px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.95)';
  ctx.fillText('2.4', rpX + 14, ry + 38);
  ctx.font = '900 20px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.55)';
  ctx.fillText('GHZ', rpX + 145, ry + 38);
  ry += 56;

  // Bigger spectrum bars — thicker
  for (let i = 0; i < 20; i++) {
    const bh = Math.random() * 60 + 10;
    const alpha = 0.15 + Math.random() * 0.45;
    const isRed = Math.random() > 0.6;
    ctx.fillStyle = isRed ? `rgba(255,80,60,${alpha})` : `rgba(255,255,255,${alpha})`;
    ctx.fillRect(rpX + 14 + i * 11, ry + 65 - bh, 9, bh);
  }
  ry += 74;

  // Waveform line — thicker
  ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i = 0; i < rpW - 28; i++) {
    const wx = rpX + 14 + i;
    const wy = ry + 12 + Math.sin(i*0.05)*10 + Math.sin(i*0.13)*6 + (Math.random()-0.5)*3;
    if (i===0) ctx.moveTo(wx,wy); else ctx.lineTo(wx,wy);
  }
  ctx.stroke();
  ry += 32;

  // Signal data — bigger, bolder
  ctx.font = '700 11px "Share Tech Mono", monospace';
  const sigLines = [
    `PWR: -${randInt(30,60)}DBM  CH: ${randInt(1,48)}`,
    `BW: ${randFloat(12,54,1)}MBPS  SNR: ${randInt(15,40)}DB`,
    `AES-256 ACTIVE  LAT: ${randInt(2,18)}MS`,
    `NODES: ${randInt(3,12)}  UPLINK: OK`,
  ];
  for (const line of sigLines) {
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.fillText(line, rpX + 14, ry);
    ry += 18;
  }

  // ENCRYPTED stamp — bigger, bolder
  ctx.font = '900 22px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,60,60,0.35)';
  ctx.fillText('ENCRYPTED', rpX + 14, ry + 12);
}

/* ===== LAYER 8: Detection stats strip (bottom overlay) ===== */
function drawStatsBanner(ctx, results, procTime) {
  const by = H - 420;
  const bw = W, bh = 100;
  drawPanel(ctx, 0, by, bw, bh, { bg: 'rgba(0,0,0,0.8)', border: false });
  // Top red accent line
  ctx.fillStyle = 'rgba(255,60,60,0.4)';
  ctx.fillRect(0, by, bw, 2);

  const obj = results.objectResults.detections.length;
  const face = results.faceResults.detections.length;
  const pose = results.poseResults.landmarks.length;
  const pers = results.objectResults.detections.filter(d=>d.categories[0].categoryName==='person').length;

  const stats = [
    { label: 'OBJECTS', value: String(obj) },
    { label: 'PERSONS', value: String(pers) },
    { label: 'FACES', value: String(face) },
    { label: 'POSES', value: String(pose) },
    { label: 'PROC', value: `${procTime}MS` },
  ];

  let sx = 30;
  for (const s of stats) {
    ctx.font = '900 40px "Share Tech Mono", monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.fillText(s.value, sx, by + 52);
    ctx.font = '700 10px "Share Tech Mono", monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.45)';
    ctx.fillText(s.label, sx, by + 70);
    sx += 145;
  }

  // RESTRICTED stamp right-aligned — bigger, bolder
  ctx.font = '900 24px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  ctx.textAlign = 'right';
  ctx.fillText('RESTRICTED', W - 30, by + 48);
  ctx.font = '700 10px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.fillText('AUTHORIZED PERSONNEL ONLY', W - 30, by + 68);
  ctx.textAlign = 'left';
}

/* ===== LAYER 9: System info panel (bottom-left, over photo) ===== */
function drawSystemPanel(ctx) {
  const px = 16, py = H - 330, pw = 520, ph = 140;
  drawPanel(ctx, px, py, pw, ph, { bg: 'rgba(0,0,0,0.85)' });

  ctx.font = '700 10px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  const lines = [
    `SYSTEM: DARK SCANNER RECON v3.1.0`,
    `DETECTOR: EFFICIENTDET-LITE0 FP16 // BLAZEFACE // LANDMARKER-LITE`,
    `POSE: LANDMARKER-LITE (33PT)  OPERATOR: [REDACTED]`,
    `AUTH: ${randHex(8)}-${randHex(4)}-${randHex(4)}`,
    `SESSION: DS-${Date.now().toString(36).toUpperCase()}  UPTIME: ${randInt(1,72)}H ${randInt(0,59)}M`,
    `ENCRYPT: AES-256-GCM  STATUS: NOMINAL  BUILD: ${randInt(100,999)}`,
  ];
  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], px + 14, py + 20 + i * 17);
  }

  // Small barcode inside panel
  drawBarcode(ctx, px + 14, py + ph - 26, 240, 16);
}

/* ===== LAYER 10: Bottom footer (over photo) ===== */
function drawBottomFooter(ctx) {
  const fy = H - 180;
  drawPanel(ctx, 0, fy, W, 180, { bg: 'rgba(0,0,0,0.85)', border: false });

  // Top line — red, thicker
  ctx.strokeStyle = 'rgba(255,60,60,0.35)'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(20, fy + 4); ctx.lineTo(W - 20, fy + 4); ctx.stroke();

  // Tagline — bigger, bolder
  ctx.font = '900 16px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.75)';
  ctx.fillText('TACTICAL IMAGE ANALYSIS', 20, fy + 32);
  ctx.fillText('FOR MODERN SURVEILLANCE', 20, fy + 52);

  // URL
  ctx.font = '700 10px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.fillText('HTTPS://PAUL13131313.GITHUB.IO/DARK-SCANNER', 20, fy + 76);

  // Brand right — bigger
  ctx.font = '900 18px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.65)';
  ctx.textAlign = 'right';
  ctx.fillText('DSK.SYSTEMS', W - 20, fy + 32);
  ctx.font = '700 11px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.fillText('暗号走査系統', W - 20, fy + 52);
  ctx.textAlign = 'left';

  // Barcode (bottom left) — bigger
  drawBarcode(ctx, 20, H - 72, 340, 32);
  ctx.font = '700 9px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  const now = new Date();
  ctx.fillText(`DSK-${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}-${randHex(6)}`, 20, H - 34);

  // QR block (bottom right) — bigger
  drawQRBlock(ctx, W - 100, H - 100, 4, 22, 22);
  ctx.font = '700 9px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.textAlign = 'right';
  ctx.fillText(randHex(12), W - 20, H - 10);
  ctx.textAlign = 'left';

  // Number row (01 02 ... 10) — bigger
  ctx.font = '700 12px "Share Tech Mono", monospace';
  const nrY = fy + 96;
  for (let i = 1; i <= 10; i++) {
    const nx = 20 + (i - 1) * 44;
    ctx.fillStyle = i === 4 ? 'rgba(255,255,255,0.8)' : 'rgba(255,255,255,0.2)';
    ctx.fillText(String(i).padStart(2, '0'), nx, nrY);
    if (i === 4) {
      ctx.strokeStyle = 'rgba(255,60,60,0.5)'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(nx, nrY + 4); ctx.lineTo(nx + 18, nrY + 4); ctx.stroke();
    }
  }
}

/* ===== LAYER 11: Fingerprint biometric data ===== */
function drawFingerprint(ctx) {
  const fpX = W - 190, fpY = H - 600;
  const fpW = 160, fpH = 200;

  // Panel background
  drawPanel(ctx, fpX - 10, fpY - 24, fpW + 20, fpH + 70, { bg: 'rgba(0,0,0,0.90)', borderColor: 'rgba(255,60,60,0.3)' });
  ctx.font = '700 9px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,60,60,0.8)';
  ctx.fillText('■  BIOMETRIC_FP', fpX - 4, fpY - 10);

  // Draw the real fingerprint image (inverted white on transparent)
  if (fingerprintCanvas) {
    // Crop center region of the source image (fingerprint is centered)
    const srcW = fingerprintCanvas.width;   // 500
    const srcH = fingerprintCanvas.height;  // 262
    // Extract a tall crop from the center, matching panel aspect ratio
    const cropAspect = fpW / fpH; // 160/200 = 0.8
    let cropH = srcH * 0.95;  // Use most of the height
    let cropW = cropH * cropAspect;
    if (cropW > srcW) { cropW = srcW * 0.9; cropH = cropW / cropAspect; }
    const cropX = (srcW - cropW) / 2;
    const cropY = (srcH - cropH) / 2;

    ctx.globalAlpha = 0.90;
    ctx.drawImage(fingerprintCanvas, cropX, cropY, cropW, cropH, fpX, fpY, fpW, fpH);
    ctx.globalAlpha = 1.0;
  }

  // Scan line with glow
  const scanProgress = (Date.now() % 3000) / 3000;
  const scanY = fpY + scanProgress * fpH;
  ctx.strokeStyle = 'rgba(255,60,60,0.5)'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(fpX, scanY); ctx.lineTo(fpX + fpW, scanY); ctx.stroke();
  const scanGrad = ctx.createLinearGradient(fpX, scanY - 15, fpX, scanY + 15);
  scanGrad.addColorStop(0, 'rgba(255,60,60,0)');
  scanGrad.addColorStop(0.5, 'rgba(255,60,60,0.08)');
  scanGrad.addColorStop(1, 'rgba(255,60,60,0)');
  ctx.fillStyle = scanGrad;
  ctx.fillRect(fpX, scanY - 15, fpW, 30);

  // Data labels
  const labelY = fpY + fpH + 8;
  ctx.font = '900 16px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.85)';
  ctx.fillText('FP-MATCH', fpX - 4, labelY);
  ctx.fillStyle = 'rgba(255,60,60,0.9)';
  ctx.fillText(`${randInt(87,99)}.${randInt(1,9)}%`, fpX + 100, labelY);

  ctx.font = '700 9px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText(`MINUTIAE: ${randInt(42,78)}  TYPE: LOOP`, fpX - 4, labelY + 16);
  ctx.fillText(`LATENT: ${randHex(8).toUpperCase()}`, fpX - 4, labelY + 30);
}

/* ===== LAYER 12: Scanlines ===== */
function drawScanlines(ctx) {
  ctx.fillStyle = 'rgba(0,0,0,0.04)';
  for (let y = 0; y < H; y += 3) ctx.fillRect(0, y, W, 1);
}

/* ===== MASTER RENDER ===== */
async function renderHUD(sourceImage, results) {
  await document.fonts.ready;
  const ctx = hudCtx;
  ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';

  // Layer 1: Photo fills entire canvas
  drawPhoto(ctx, sourceImage);

  // Layer 2: X-cross + grid
  drawCrossLines(ctx);

  // Layer 3: Detection overlays
  drawDetections(ctx, results, sourceImage);

  // Layer 4: Giant typography
  drawGiantText(ctx);

  // Layer 5: Header panel
  drawHeaderPanel(ctx);

  // Layer 6: Left data panel
  drawLeftPanel(ctx, results);

  // Layer 7: Right side panels
  drawRightPanels(ctx, sourceImage, results);

  // Layer 8: Stats strip
  drawStatsBanner(ctx, results, results.procTime);

  // Layer 9: System panel
  drawSystemPanel(ctx);

  // Layer 10: Bottom footer
  drawBottomFooter(ctx);

  // Layer 11: Fingerprint biometric
  drawFingerprint(ctx);

  // Layer 12: Global effects
  drawCornerBrackets(ctx, 4, 4, W-8, H-8, 40, 1.5, 'rgba(255,255,255,0.08)');
  drawScanlines(ctx);
}

/* ===== PNG SAVE ===== */
function savePNG() {
  hudCanvas.toBlob(async (blob) => {
    const filename = `dark-scanner-${Date.now()}.png`;
    if (navigator.share && navigator.canShare) {
      const file = new File([blob], filename, { type: 'image/png' });
      const shareData = { files: [file] };
      if (navigator.canShare(shareData)) {
        try {
          await navigator.share(shareData);
          return;
        } catch (e) {
          // User cancelled or share failed, fall through to download
        }
      }
    }
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  }, 'image/png');
}

/* ===== EVENT HANDLERS ===== */
btnCamera.addEventListener('click', async () => {
  showScreen('camera-screen');
  await startCamera();
});

btnUpload.addEventListener('click', () => {
  fileInput.click();
});

btnGallery.addEventListener('click', () => {
  fileInput.click();
});

fileInput.addEventListener('change', async (e) => {
  let file = e.target.files[0];
  if (!file) return;

  stopCamera();

  // HEIC/HEIF conversion for iPhone photos
  const isHEIC = file.type === 'image/heic' || file.type === 'image/heif'
    || /\.heic$/i.test(file.name) || /\.heif$/i.test(file.name);
  if (isHEIC && window.heic2any) {
    try {
      const startEl = document.querySelector('.start-footer');
      if (startEl) startEl.textContent = 'CONVERTING HEIC...';
      const blob = await heic2any({ blob: file, toType: 'image/jpeg', quality: 0.92 });
      file = new File([blob], file.name.replace(/\.heic$/i, '.jpg'), { type: 'image/jpeg' });
    } catch (err) {
      console.error('HEIC conversion failed:', err);
    }
  }

  const img = new Image();
  img.onload = async () => {
    const results = await analyzeImage(img);
    await renderHUD(img, results);
    showScreen('result-screen');
    URL.revokeObjectURL(img.src);
  };
  img.src = URL.createObjectURL(file);
  e.target.value = '';
});

btnScan.addEventListener('click', async () => {
  const capturedCanvas = captureFrame();
  stopCamera();

  const img = new Image();
  img.onload = async () => {
    const results = await analyzeImage(img);
    await renderHUD(img, results);
    showScreen('result-screen');
  };
  img.src = capturedCanvas.toDataURL();
});

btnFlip.addEventListener('click', async () => {
  currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
  await startCamera();
});

btnBackStart.addEventListener('click', () => {
  stopCamera();
  showScreen('start-screen');
});

btnSave.addEventListener('click', savePNG);

btnNew.addEventListener('click', () => {
  showScreen('start-screen');
});

/* ===== INIT ===== */
initModels();
</script>
</body>
</html>
