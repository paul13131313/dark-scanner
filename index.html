<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>DARK SCANNER — Tactical Image Analysis</title>

<!-- OGP -->
<meta property="og:title" content="DARK SCANNER">
<meta property="og:description" content="MediaPipeで人物・顔・ポーズを検出し、CIA/軍事偵察分析風のダークテックHUDで加工する画像ジェネレーター">
<meta property="og:image" content="https://paul13131313.github.io/dark-scanner/ogp.png">
<meta property="og:url" content="https://paul13131313.github.io/dark-scanner/">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">

<!-- Favicon -->
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%23000'/><text x='50' y='62' text-anchor='middle' font-size='50' fill='%23fff'>⊕</text></svg>">

<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000; color: #fff;
    font-family: 'Share Tech Mono', 'SF Mono', 'Fira Code', 'Courier New', monospace;
    overflow: hidden; text-transform: uppercase;
    letter-spacing: 1px;
    -webkit-user-select: none; user-select: none;
    touch-action: manipulation;
  }

  /* ===== START SCREEN ===== */
  .screen { position: fixed; inset: 0; display: none; z-index: 10; }
  .screen.active { display: flex; }

  #start-screen {
    flex-direction: column; align-items: center; justify-content: center;
    background: #000;
  }
  #start-screen::before {
    content: ''; position: absolute; inset: 0;
    background:
      repeating-linear-gradient(0deg, transparent, transparent 79px, rgba(255,255,255,0.03) 79px, rgba(255,255,255,0.03) 80px),
      repeating-linear-gradient(90deg, transparent, transparent 79px, rgba(255,255,255,0.03) 79px, rgba(255,255,255,0.03) 80px);
    pointer-events: none;
  }
  .start-title {
    font-size: 28px; letter-spacing: 8px; font-weight: 700;
    color: rgba(255,255,255,0.9); margin-bottom: 8px; position: relative;
  }
  .start-sub {
    font-size: 10px; letter-spacing: 3px;
    color: rgba(255,255,255,0.3); margin-bottom: 6px;
  }
  .start-version {
    font-size: 9px; letter-spacing: 2px;
    color: rgba(255,255,255,0.15); margin-bottom: 40px;
  }
  #model-status {
    font-size: 10px; letter-spacing: 2px;
    color: rgba(255,255,255,0.4); margin-bottom: 30px;
    min-height: 16px;
  }
  .source-buttons {
    display: flex; flex-direction: column; gap: 12px;
    width: 220px; position: relative;
  }
  .source-btn {
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.7);
    padding: 16px 24px; font-size: 13px; letter-spacing: 3px;
    font-family: inherit; text-transform: uppercase;
    cursor: pointer; transition: all 0.3s;
    display: flex; align-items: center; justify-content: center; gap: 10px;
  }
  .source-btn:hover {
    background: rgba(255,255,255,0.1);
    border-color: rgba(255,255,255,0.4);
    color: #fff;
  }
  .source-btn:disabled {
    opacity: 0.2; cursor: default; pointer-events: none;
  }
  .source-btn .icon { font-size: 16px; }
  .start-footer {
    position: absolute; bottom: 30px;
    font-size: 9px; letter-spacing: 2px;
    color: rgba(255,255,255,0.1);
  }

  /* ===== CAMERA SCREEN ===== */
  #camera-screen {
    flex-direction: column; align-items: center; justify-content: center;
    background: #000;
  }
  #video {
    width: 100%; height: 100%; object-fit: cover;
    position: absolute; inset: 0;
  }
  .camera-hud {
    position: absolute; inset: 0; pointer-events: none;
  }
  .camera-corner {
    position: absolute; width: 30px; height: 30px;
    border-color: rgba(255,255,255,0.4); border-style: solid; border-width: 0;
  }
  .camera-corner.tl { top: 20px; left: 20px; border-top-width: 2px; border-left-width: 2px; }
  .camera-corner.tr { top: 20px; right: 20px; border-top-width: 2px; border-right-width: 2px; }
  .camera-corner.bl { bottom: 100px; left: 20px; border-bottom-width: 2px; border-left-width: 2px; }
  .camera-corner.br { bottom: 100px; right: 20px; border-bottom-width: 2px; border-right-width: 2px; }
  .camera-label {
    position: absolute; top: 30px; left: 50%;
    transform: translateX(-50%);
    font-size: 10px; letter-spacing: 3px;
    color: rgba(255,255,255,0.4);
  }
  .camera-actions {
    position: absolute; bottom: 0; left: 0; right: 0;
    display: flex; align-items: center; justify-content: center;
    padding: 20px; gap: 24px; z-index: 5;
    background: linear-gradient(transparent, rgba(0,0,0,0.8));
  }
  #btn-scan {
    width: 64px; height: 64px; border-radius: 50%;
    background: transparent;
    border: 3px solid rgba(255,255,255,0.8);
    cursor: pointer; position: relative;
    transition: all 0.2s;
  }
  #btn-scan::after {
    content: ''; position: absolute;
    top: 5px; left: 5px; right: 5px; bottom: 5px;
    border-radius: 50%;
    background: #ff3333;
    transition: all 0.2s;
  }
  #btn-scan:active::after { transform: scale(0.9); }
  .cam-ctrl-btn {
    width: 44px; height: 44px; border-radius: 50%;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.7);
    font-size: 18px; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    font-family: inherit;
  }
  #btn-back-start {
    position: absolute; top: 16px; left: 16px;
    width: 40px; height: 40px; border-radius: 50%;
    background: rgba(0,0,0,0.5);
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.7);
    font-size: 18px; cursor: pointer; z-index: 5;
    display: flex; align-items: center; justify-content: center;
    font-family: inherit;
  }

  /* ===== ANALYZING SCREEN ===== */
  #analyzing-screen {
    flex-direction: column; align-items: center; justify-content: center;
    background: #000;
  }
  .analyze-title {
    font-size: 14px; letter-spacing: 4px;
    color: rgba(255,255,255,0.7); margin-bottom: 24px;
  }
  .progress-bar {
    width: 260px; height: 4px;
    background: rgba(255,255,255,0.08); margin-bottom: 16px;
  }
  .progress-fill {
    height: 100%; width: 0%;
    background: #fff; transition: width 0.3s;
  }
  .analyze-detail {
    font-size: 9px; letter-spacing: 2px;
    color: rgba(255,255,255,0.3);
  }

  /* ===== RESULT SCREEN ===== */
  #result-screen {
    flex-direction: column; align-items: center; justify-content: center;
    background: #000; overflow: auto;
    -webkit-overflow-scrolling: touch;
  }
  #result-screen canvas {
    max-width: 100%; max-height: calc(100vh - 80px);
    object-fit: contain;
  }
  .result-actions {
    position: fixed; bottom: 0; left: 0; right: 0;
    display: flex; justify-content: center; gap: 12px;
    padding: 16px;
    background: linear-gradient(transparent, rgba(0,0,0,0.95));
    z-index: 15;
  }
  .result-btn {
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.25);
    color: rgba(255,255,255,0.8);
    padding: 12px 28px; font-size: 12px; letter-spacing: 3px;
    font-family: inherit; text-transform: uppercase;
    cursor: pointer; transition: all 0.3s;
    display: flex; align-items: center; gap: 8px;
  }
  .result-btn:hover {
    background: rgba(255,255,255,0.1);
    border-color: rgba(255,255,255,0.5);
    color: #fff;
  }
  .result-btn .icon { font-size: 14px; }
</style>
</head>
<body>

<!-- START SCREEN -->
<div id="start-screen" class="screen active">
  <div class="start-title">DARK SCANNER</div>
  <div class="start-sub">TACTICAL IMAGE ANALYSIS SYSTEM</div>
  <div class="start-version">RECON v3.1.0</div>
  <div id="model-status">INITIALIZING SYSTEM...</div>
  <div class="source-buttons">
    <button class="source-btn" id="btn-camera" disabled>
      <span class="icon">&#9711;</span> CAMERA
    </button>
    <button class="source-btn" id="btn-upload" disabled>
      <span class="icon">&#9645;</span> UPLOAD
    </button>
  </div>
  <input type="file" id="file-input" accept="image/*" hidden>
  <div class="start-footer">SYSTEM: STANDBY</div>
</div>

<!-- CAMERA SCREEN -->
<div id="camera-screen" class="screen">
  <video id="video" autoplay playsinline muted></video>
  <button id="btn-back-start">&larr;</button>
  <div class="camera-hud">
    <div class="camera-corner tl"></div>
    <div class="camera-corner tr"></div>
    <div class="camera-corner bl"></div>
    <div class="camera-corner br"></div>
    <div class="camera-label">SCANNING TARGET...</div>
  </div>
  <div class="camera-actions">
    <button class="cam-ctrl-btn" id="btn-flip">&#8635;</button>
    <button id="btn-scan"></button>
    <button class="cam-ctrl-btn" id="btn-gallery">&#9645;</button>
  </div>
</div>

<!-- ANALYZING SCREEN -->
<div id="analyzing-screen" class="screen">
  <div class="analyze-title">&#9654; ANALYZING...</div>
  <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
  <div class="analyze-detail" id="analyze-detail">INITIALIZING DETECTORS</div>
</div>

<!-- RESULT SCREEN -->
<div id="result-screen" class="screen">
  <canvas id="hud-canvas" width="1080" height="1920"></canvas>
  <div class="result-actions">
    <button class="result-btn" id="btn-save"><span class="icon">&#8681;</span> SAVE</button>
    <button class="result-btn" id="btn-new"><span class="icon">&#9711;</span> NEW</button>
  </div>
</div>

<script type="module">
import vision from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js';
const { ObjectDetector, FaceDetector, PoseLandmarker, FilesetResolver } = vision;

/* ===== STATE ===== */
let objectDetector = null;
let faceDetector = null;
let poseLandmarker = null;
let currentFacingMode = 'environment';
let currentStream = null;

/* ===== ELEMENTS ===== */
const startScreen = document.getElementById('start-screen');
const cameraScreen = document.getElementById('camera-screen');
const analyzingScreen = document.getElementById('analyzing-screen');
const resultScreen = document.getElementById('result-screen');
const modelStatus = document.getElementById('model-status');
const btnCamera = document.getElementById('btn-camera');
const btnUpload = document.getElementById('btn-upload');
const btnScan = document.getElementById('btn-scan');
const btnFlip = document.getElementById('btn-flip');
const btnGallery = document.getElementById('btn-gallery');
const btnBackStart = document.getElementById('btn-back-start');
const btnSave = document.getElementById('btn-save');
const btnNew = document.getElementById('btn-new');
const fileInput = document.getElementById('file-input');
const videoEl = document.getElementById('video');
const progressFill = document.getElementById('progress-fill');
const analyzeDetail = document.getElementById('analyze-detail');
const hudCanvas = document.getElementById('hud-canvas');
const hudCtx = hudCanvas.getContext('2d');

/* ===== CONSTANTS ===== */
const W = 1080;
const H = 1920;
const M = 30;

/* ===== POSE CONNECTIONS ===== */
const POSE_CONNECTIONS = [
  [0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],
  [9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],
  [17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],
  [11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],
  [27,29],[28,30],[29,31],[30,32],[27,31],[28,32]
];

/* ===== SCREEN MANAGEMENT ===== */
function showScreen(id) {
  [startScreen, cameraScreen, analyzingScreen, resultScreen].forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

/* ===== MODEL INITIALIZATION ===== */
async function initModels() {
  try {
    modelStatus.textContent = 'LOADING VISION RUNTIME...';
    const filesetResolver = await FilesetResolver.forVisionTasks(
      'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm'
    );

    modelStatus.textContent = 'LOADING MODEL 1/3 — OBJECT DETECTOR...';
    objectDetector = await ObjectDetector.createFromOptions(filesetResolver, {
      baseOptions: {
        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/object_detector/efficientdet_lite0/float16/1/efficientdet_lite0.tflite',
        delegate: 'GPU'
      },
      maxResults: 10,
      scoreThreshold: 0.3,
      runningMode: 'IMAGE'
    });

    modelStatus.textContent = 'LOADING MODEL 2/3 — FACE DETECTOR...';
    faceDetector = await FaceDetector.createFromOptions(filesetResolver, {
      baseOptions: {
        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_detector/blaze_face_short_range/float16/1/blaze_face_short_range.tflite',
        delegate: 'GPU'
      },
      runningMode: 'IMAGE'
    });

    modelStatus.textContent = 'LOADING MODEL 3/3 — POSE LANDMARKER...';
    poseLandmarker = await PoseLandmarker.createFromOptions(filesetResolver, {
      baseOptions: {
        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task',
        delegate: 'GPU'
      },
      runningMode: 'IMAGE',
      numPoses: 5
    });

    modelStatus.textContent = 'ALL SYSTEMS OPERATIONAL';
    btnCamera.disabled = false;
    btnUpload.disabled = false;
    document.querySelector('.start-footer').textContent = 'SYSTEM: READY';
  } catch (e) {
    console.error('Model init error:', e);
    modelStatus.textContent = 'ERROR: ' + e.message;
  }
}

/* ===== CAMERA ===== */
async function startCamera() {
  try {
    if (currentStream) {
      currentStream.getTracks().forEach(t => t.stop());
    }
    currentStream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: currentFacingMode, width: { ideal: 1080 }, height: { ideal: 1920 } }
    });
    videoEl.srcObject = currentStream;
    await new Promise(r => { videoEl.onloadeddata = r; });
  } catch (e) {
    console.error('Camera error:', e);
    alert('CAMERA ACCESS DENIED');
    showScreen('start-screen');
  }
}

function stopCamera() {
  if (currentStream) {
    currentStream.getTracks().forEach(t => t.stop());
    currentStream = null;
  }
}

function captureFrame() {
  const c = document.createElement('canvas');
  c.width = videoEl.videoWidth;
  c.height = videoEl.videoHeight;
  const cx = c.getContext('2d');
  cx.drawImage(videoEl, 0, 0);
  return c;
}

/* ===== DETECTION ===== */
async function analyzeImage(imageSource) {
  showScreen('analyzing-screen');
  progressFill.style.width = '0%';

  analyzeDetail.textContent = 'RUNNING OBJECT DETECTION...';
  progressFill.style.width = '10%';
  await new Promise(r => setTimeout(r, 50));
  const t0 = performance.now();
  const objectResults = objectDetector.detect(imageSource);
  progressFill.style.width = '33%';

  analyzeDetail.textContent = 'RUNNING FACE DETECTION...';
  await new Promise(r => setTimeout(r, 50));
  const faceResults = faceDetector.detect(imageSource);
  progressFill.style.width = '66%';

  analyzeDetail.textContent = 'RUNNING POSE ESTIMATION...';
  await new Promise(r => setTimeout(r, 50));
  const poseResults = poseLandmarker.detect(imageSource);
  progressFill.style.width = '90%';

  const procTime = Math.round(performance.now() - t0);

  analyzeDetail.textContent = 'GENERATING HUD OVERLAY...';
  progressFill.style.width = '100%';
  await new Promise(r => setTimeout(r, 200));

  return { objectResults, faceResults, poseResults, procTime };
}

/* ===== FAKE DATA GENERATORS ===== */
function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function randFloat(min, max, dec) { return (Math.random() * (max - min) + min).toFixed(dec); }
function randHex(len) { return Array.from({length: len}, () => Math.floor(Math.random() * 16).toString(16)).join('').toUpperCase(); }

function formatTimestamp() {
  const now = new Date();
  const y = now.getFullYear();
  const m = String(now.getMonth()+1).padStart(2,'0');
  const d = String(now.getDate()).padStart(2,'0');
  const hh = String(now.getHours()).padStart(2,'0');
  const mm = String(now.getMinutes()).padStart(2,'0');
  const ss = String(now.getSeconds()).padStart(2,'0');
  return { date: `${y}.${m}.${d}`, time: `${hh}:${mm}:${ss} JST` };
}

/* =========================================================
   HUD DRAWING — V5: PHOTO-DOMINANT OVERLAY
   - Photo fills nearly the entire canvas (edge-to-edge)
   - ALL elements overlay ON TOP of the photo
   - Extreme text size contrast (140px ↔ 8px)
   - Clean data panels with semi-transparent backgrounds
   - Monochrome, high contrast
   ========================================================= */

function calcAngle(a, b, c) {
  const ab = { x: a.x - b.x, y: a.y - b.y };
  const cb = { x: c.x - b.x, y: c.y - b.y };
  const dot = ab.x * cb.x + ab.y * cb.y;
  const mA = Math.sqrt(ab.x*ab.x + ab.y*ab.y);
  const mC = Math.sqrt(cb.x*cb.x + cb.y*cb.y);
  if (mA === 0 || mC === 0) return 0;
  return Math.round(Math.acos(Math.max(-1, Math.min(1, dot/(mA*mC)))) * 180 / Math.PI);
}

/* --- Helpers --- */
function drawCornerBrackets(ctx, x, y, w, h, len, lw, color) {
  ctx.strokeStyle = color; ctx.lineWidth = lw;
  ctx.beginPath(); ctx.moveTo(x, y+len); ctx.lineTo(x, y); ctx.lineTo(x+len, y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x+w-len, y); ctx.lineTo(x+w, y); ctx.lineTo(x+w, y+len); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x, y+h-len); ctx.lineTo(x, y+h); ctx.lineTo(x+len, y+h); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x+w-len, y+h); ctx.lineTo(x+w, y+h); ctx.lineTo(x+w, y+h-len); ctx.stroke();
}

function drawBarcode(ctx, x, y, w, h) {
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  let cx = x;
  while (cx < x + w) {
    const bw = Math.random() > 0.5 ? 1 : 3;
    const gap = Math.random() > 0.5 ? 2 : 3;
    ctx.fillRect(cx, y, bw, h);
    cx += bw + gap;
  }
}

function drawQRBlock(ctx, qx, qy, cellSize, cols, rows) {
  for (const [cx,cy] of [[0,0],[cols-5,0],[0,rows-5]]) {
    for (let r=0;r<5;r++) for (let c=0;c<5;c++) {
      if (r===0||r===4||c===0||c===4||(r>=1&&r<=3&&c>=1&&c<=3)) {
        ctx.fillStyle = 'rgba(255,255,255,0.55)';
        ctx.fillRect(qx+(cx+c)*cellSize, qy+(cy+r)*cellSize, cellSize-1, cellSize-1);
      }
    }
  }
  for (let r=0;r<rows;r++) for (let c=0;c<cols;c++) {
    if (c<5&&r<5) continue; if (c>=cols-5&&r<5) continue; if (c<5&&r>=rows-5) continue;
    if (Math.random()>0.5) {
      ctx.fillStyle = `rgba(255,255,255,${0.1+Math.random()*0.25})`;
      ctx.fillRect(qx+c*cellSize, qy+r*cellSize, cellSize-1, cellSize-1);
    }
  }
}

/* Draw a clean data panel with semi-transparent BG */
function drawPanel(ctx, x, y, w, h, opts = {}) {
  ctx.fillStyle = opts.bg || 'rgba(0,0,0,0.65)';
  ctx.fillRect(x, y, w, h);
  if (opts.border !== false) {
    ctx.strokeStyle = opts.borderColor || 'rgba(255,255,255,0.1)';
    ctx.lineWidth = 0.5;
    ctx.strokeRect(x, y, w, h);
  }
}

/* ===== PHOTO — nearly full canvas ===== */
const PHOTO_X = 0;
const PHOTO_Y = 0;
const PHOTO_W = W;    // 1080
const PHOTO_H = H;    // 1920

/* ===== LAYER 1: Photo fills entire canvas (monochrome) ===== */
function drawPhoto(ctx, src) {
  const sW = src.width, sH = src.height;
  const scale = Math.max(PHOTO_W / sW, PHOTO_H / sH);
  const dW = sW * scale, dH = sH * scale;
  const ox = (PHOTO_W - dW) / 2;
  const oy = (PHOTO_H - dH) / 2;

  ctx.drawImage(src, ox, oy, dW, dH);

  // Monochrome + high contrast
  const imageData = ctx.getImageData(0, 0, W, H);
  const d = imageData.data;
  for (let i = 0; i < d.length; i += 4) {
    let lum = (d[i] * 0.299 + d[i+1] * 0.587 + d[i+2] * 0.114);
    lum = lum < 80 ? lum * 0.4 : Math.min(255, lum * 1.2 + 10);
    d[i] = d[i+1] = d[i+2] = lum;
  }
  ctx.putImageData(imageData, 0, 0);

  // Top gradient fade (for header readability)
  const gTop = ctx.createLinearGradient(0, 0, 0, 320);
  gTop.addColorStop(0, 'rgba(0,0,0,0.7)');
  gTop.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = gTop; ctx.fillRect(0, 0, W, 320);

  // Bottom gradient fade (for footer readability)
  const gBot = ctx.createLinearGradient(0, H - 500, 0, H);
  gBot.addColorStop(0, 'rgba(0,0,0,0)');
  gBot.addColorStop(1, 'rgba(0,0,0,0.8)');
  ctx.fillStyle = gBot; ctx.fillRect(0, H - 500, W, 500);

  // Subtle vignette
  const gVig = ctx.createRadialGradient(W/2, H*0.4, W*0.2, W/2, H*0.4, W*0.8);
  gVig.addColorStop(0, 'rgba(0,0,0,0)');
  gVig.addColorStop(1, 'rgba(0,0,0,0.35)');
  ctx.fillStyle = gVig; ctx.fillRect(0, 0, W, H);
}

/* ===== LAYER 2: X-cross + grid lines (over photo) ===== */
function drawCrossLines(ctx) {
  // Diagonal X
  ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(W, H); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(W, 0); ctx.lineTo(0, H); ctx.stroke();

  // Center cross
  ctx.strokeStyle = 'rgba(255,255,255,0.035)';
  ctx.beginPath(); ctx.moveTo(0, H/2); ctx.lineTo(W, H/2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(W/2, 0); ctx.lineTo(W/2, H); ctx.stroke();

  // Subtle grid
  ctx.strokeStyle = 'rgba(255,255,255,0.02)'; ctx.lineWidth = 0.5;
  for (let x = 0; x < W; x += 60) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for (let y = 0; y < H; y += 60) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
}

/* ===== LAYER 3: Detection overlays (on full photo) ===== */
function drawDetections(ctx, results, src) {
  const sW = src.width, sH = src.height;
  const scale = Math.max(W / sW, H / sH);
  const baseOX = (W - sW * scale) / 2;
  const baseOY = (H - sH * scale) / 2;

  // --- Object brackets ---
  const subjNames = ['ALPHA','BRAVO','CHARLIE','DELTA','ECHO'];
  let pIdx = 0;
  for (const det of results.objectResults.detections) {
    const b = det.boundingBox;
    const cat = det.categories[0];
    const label = cat.categoryName.toUpperCase();
    const score = Math.round(cat.score * 100);
    const bx = b.originX * scale + baseOX;
    const by = b.originY * scale + baseOY;
    const bw = b.width * scale;
    const bh = b.height * scale;
    const bl = Math.min(bw, bh) * 0.12;
    ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(bx, by+bl); ctx.lineTo(bx, by); ctx.lineTo(bx+bl, by); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(bx+bw-bl, by); ctx.lineTo(bx+bw, by); ctx.lineTo(bx+bw, by+bl); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(bx, by+bh-bl); ctx.lineTo(bx, by+bh); ctx.lineTo(bx+bl, by+bh); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(bx+bw-bl, by+bh); ctx.lineTo(bx+bw, by+bh); ctx.lineTo(bx+bw, by+bh-bl); ctx.stroke();
    const isPerson = label === 'PERSON';
    const dLabel = isPerson ? `SUBJ-${subjNames[pIdx]||pIdx}` : label;
    if (isPerson) pIdx++;
    ctx.font = '700 12px "Share Tech Mono", monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    ctx.textAlign = 'left'; ctx.fillText(dLabel, bx+4, by-6);
    ctx.textAlign = 'right'; ctx.fillText(`${score}%`, bx+bw-4, by-6);
    ctx.textAlign = 'left';
  }

  // --- Pose skeleton ---
  for (const lm of results.poseResults.landmarks) {
    const pts = lm.map(p => ({ x: p.x*sW*scale+baseOX, y: p.y*sH*scale+baseOY, v: p.visibility }));
    ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 1;
    for (const [a,b] of POSE_CONNECTIONS) {
      if (a>=pts.length||b>=pts.length) continue;
      if (pts[a].v<0.4||pts[b].v<0.4) continue;
      ctx.beginPath(); ctx.moveTo(pts[a].x, pts[a].y); ctx.lineTo(pts[b].x, pts[b].y); ctx.stroke();
    }
    for (const p of pts) {
      if (p.v<0.4) continue;
      ctx.fillStyle = 'rgba(255,255,255,0.35)';
      ctx.beginPath(); ctx.arc(p.x, p.y, 2.5, 0, Math.PI*2); ctx.fill();
    }
  }

  // --- Face targeting ---
  for (const det of results.faceResults.detections) {
    const b = det.boundingBox;
    const fcx = b.originX*scale+baseOX + b.width*scale/2;
    const fcy = b.originY*scale+baseOY + b.height*scale/2;
    const r = Math.max(b.width,b.height)*scale*0.5;
    ctx.setLineDash([8,5]); ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(fcx,fcy,r,0,Math.PI*2); ctx.stroke();
    ctx.setLineDash([]);
    ctx.strokeStyle = 'rgba(255,255,255,0.45)'; ctx.lineWidth = 2;
    for (let i=0;i<4;i++) {
      const a = i*Math.PI/2;
      ctx.beginPath();
      ctx.moveTo(fcx+Math.cos(a)*(r-6), fcy+Math.sin(a)*(r-6));
      ctx.lineTo(fcx+Math.cos(a)*(r+6), fcy+Math.sin(a)*(r+6));
      ctx.stroke();
    }
  }
}

/* ===== LAYER 4: GIANT typography (overlaid on photo) ===== */
function drawGiantText(ctx) {
  // "SCAN.XX" — massive, top-right, overlapping photo
  ctx.font = '700 140px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.textAlign = 'right';
  ctx.fillText(`SCAN`, W - 20, 180);
  ctx.font = '700 80px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.25)';
  ctx.fillText(`.${String(randInt(1,12)).padStart(2,'0')}`, W - 20, 250);
  ctx.textAlign = 'left';

  // "DARK SCANNER" — huge watermark, center-left, over the body
  ctx.save();
  ctx.translate(80, H * 0.55);
  ctx.rotate(-Math.PI / 2);
  ctx.font = '700 110px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  ctx.textAlign = 'center';
  ctx.fillText('DARK SCANNER', 0, 0);
  ctx.restore();

  // Japanese accent — 暗号走査 — bottom area
  ctx.font = '700 72px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.07)';
  ctx.textAlign = 'left';
  ctx.fillText('暗号走査', 30, H - 460);
}

/* ===== LAYER 5: Top header panel (over photo) ===== */
function drawHeaderPanel(ctx) {
  drawPanel(ctx, 0, 0, W, 52);
  const ts = formatTimestamp();
  ctx.font = '700 18px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.textAlign = 'left';
  ctx.fillText('DARK SCANNER', 20, 34);

  // REC indicator
  ctx.fillStyle = '#ff3333';
  ctx.beginPath(); ctx.arc(260, 30, 4, 0, Math.PI*2); ctx.fill();
  ctx.font = '10px "Share Tech Mono", monospace';
  ctx.fillStyle = '#ff3333'; ctx.fillText('REC', 270, 34);

  ctx.font = '9px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.fillText('CAM-01 // RECON v3.1', 320, 34);

  ctx.textAlign = 'right';
  ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.font = '11px "Share Tech Mono", monospace';
  ctx.fillText(`${ts.date}  ${ts.time}`, W - 20, 34);
  ctx.textAlign = 'left';
}

/* ===== LAYER 6: Left data panel (over photo, semi-transparent) ===== */
function drawLeftPanel(ctx, results) {
  const px = 16, py = 68, pw = 240, ph = 420;
  drawPanel(ctx, px, py, pw, ph);

  let y = py + 18;
  const x = px + 14;

  // Section: ORGANIZATION
  ctx.font = '7px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.fillText('ORGANIZATION  組織', x, y);
  ctx.font = '11px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.fillText('DSK.SYSTEMS', x, y + 14);
  y += 36;

  // Section: COLLECTION
  ctx.font = '7px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.fillText('COLLECTION  収集', x, y);
  ctx.font = '11px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.fillText('RECON-3-SURVEILLANCE', x, y + 14);
  y += 36;

  // Section: SESSION
  ctx.font = '7px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.fillText('SESSION  区分', x, y);
  ctx.font = '11px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  const ts = formatTimestamp();
  ctx.fillText(ts.date + ' // ' + ts.time, x, y + 14);
  y += 36;

  // Separator
  ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + pw - 28, y); ctx.stroke();
  y += 14;

  // Section: CODENAME with icon
  ctx.font = '7px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.fillText('CODENAME  識別', x, y);
  y += 16;
  // Crosshair icon
  ctx.strokeStyle = 'rgba(255,255,255,0.45)'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.arc(x+8, y+2, 6, 0, Math.PI*2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x+8, y-4); ctx.lineTo(x+8, y+8); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x+2, y+2); ctx.lineTo(x+14, y+2); ctx.stroke();
  ctx.font = '700 12px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.fillText(`DSK-RN${randInt(1,9)}-SC${randInt(10,99)}-BK`, x + 22, y + 6);
  y += 28;

  // Separator
  ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + pw - 28, y); ctx.stroke();
  y += 14;

  // Subject data rows
  const persons = results.objectResults.detections.filter(d=>d.categories[0].categoryName==='person');
  const hasFace = results.faceResults.detections.length > 0;
  const fields = [
    ['STATUS', 'ACTIVE'],
    ['CLASS', persons.length > 0 ? 'CIVILIAN' : 'UNKNOWN'],
    ['THREAT', ['LOW','MODERATE','ELEVATED','HIGH'][randInt(0,3)]],
    ['HR', `${randInt(62,82)} BPM`],
    ['THERMAL', `${randFloat(36.1,37.2,1)}°C`],
    ['BIOMETRIC', hasFace ? 'SCANNING' : 'N/A'],
    ['BEARING', `${randInt(0,359)}°`],
    ['RANGE', `${randFloat(1.0,8.0,1)}M`],
  ];
  for (const f of fields) {
    ctx.font = '7px "Share Tech Mono", monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillText(f[0], x, y);
    ctx.font = '10px "Share Tech Mono", monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.fillText(f[1], x + 68, y);
    y += 17;
  }
}

/* ===== LAYER 7: Right side panels (over photo) ===== */
function drawRightPanels(ctx, src, results) {
  // Sub-image panel 1 (cropped face/upper body)
  const subX = W - 200, subY = 300, subW = 170, subH = 190;
  drawPanel(ctx, subX - 4, subY - 16, subW + 8, subH + 20, { bg: 'rgba(0,0,0,0.55)' });
  ctx.font = '7px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.fillText('■  PROFILE_CLOSE', subX, subY - 4);

  ctx.save();
  ctx.beginPath(); ctx.rect(subX, subY, subW, subH); ctx.clip();
  const crScale = Math.max(subW / src.width, subH / (src.height * 0.35));
  ctx.drawImage(src, 0, 0, src.width, src.height * 0.35, subX, subY, src.width * crScale, src.height * 0.35 * crScale);
  const sd1 = ctx.getImageData(subX, subY, subW, subH);
  for (let i = 0; i < sd1.data.length; i += 4) {
    let l = sd1.data[i]*0.299 + sd1.data[i+1]*0.587 + sd1.data[i+2]*0.114;
    l = l < 80 ? l * 0.4 : Math.min(255, l * 1.1);
    sd1.data[i] = sd1.data[i+1] = sd1.data[i+2] = l;
  }
  ctx.putImageData(sd1, subX, subY);
  ctx.restore();

  // Sub-image panel 2 (mid body crop)
  const sub2Y = subY + subH + 26;
  drawPanel(ctx, subX - 4, sub2Y - 16, subW + 8, subH + 20, { bg: 'rgba(0,0,0,0.55)' });
  ctx.font = '7px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.fillText('■  DETAIL_MID', subX, sub2Y - 4);

  ctx.save();
  ctx.beginPath(); ctx.rect(subX, sub2Y, subW, subH); ctx.clip();
  const cr2Scale = Math.max(subW / src.width, subH / (src.height * 0.35));
  ctx.drawImage(src, 0, src.height*0.3, src.width, src.height*0.35, subX, sub2Y, src.width*cr2Scale, src.height*0.35*cr2Scale);
  const sd2 = ctx.getImageData(subX, sub2Y, subW, subH);
  for (let i = 0; i < sd2.data.length; i += 4) {
    let l = sd2.data[i]*0.299 + sd2.data[i+1]*0.587 + sd2.data[i+2]*0.114;
    l = l < 80 ? l * 0.4 : Math.min(255, l * 1.1);
    sd2.data[i] = sd2.data[i+1] = sd2.data[i+2] = l;
  }
  ctx.putImageData(sd2, subX, sub2Y);
  ctx.restore();

  // Right data panel (signal + specs)
  const rpX = W - 240, rpY = sub2Y + subH + 30, rpW = 222, rpH = 260;
  drawPanel(ctx, rpX, rpY, rpW, rpH);
  let ry = rpY + 16;
  ctx.font = '7px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.fillText('SIGNAL  信号', rpX + 12, ry);
  ry += 14;

  // Big freq number
  ctx.font = '700 36px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.85)';
  ctx.fillText('2.4', rpX + 12, ry + 28);
  ctx.font = '11px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.fillText('GHZ', rpX + 115, ry + 28);
  ry += 46;

  // Mini spectrum bars
  for (let i = 0; i < 18; i++) {
    const bh = Math.random() * 30 + 4;
    const alpha = 0.08 + Math.random() * 0.22;
    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    ctx.fillRect(rpX + 12 + i * 11, ry + 40 - bh, 8, bh);
  }
  ry += 50;

  // Tiny signal data
  ctx.font = '8px "Share Tech Mono", monospace';
  const sigLines = [
    `PWR: -${randInt(30,60)}DBM  CH: ${randInt(1,48)}`,
    `BW: ${randFloat(12,54,1)}MBPS  SNR: ${randInt(15,40)}DB`,
    `AES-256 ACTIVE`,
    `LATENCY: ${randInt(2,18)}MS`,
    `NODES: ${randInt(3,12)}  UPLINK: OK`,
  ];
  for (const line of sigLines) {
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.fillText(line, rpX + 12, ry);
    ry += 14;
  }
}

/* ===== LAYER 8: Detection stats strip (bottom overlay) ===== */
function drawStatsBanner(ctx, results, procTime) {
  const by = H - 400;
  const bw = W, bh = 80;
  drawPanel(ctx, 0, by, bw, bh, { bg: 'rgba(0,0,0,0.5)', border: false });

  const obj = results.objectResults.detections.length;
  const face = results.faceResults.detections.length;
  const pose = results.poseResults.landmarks.length;
  const pers = results.objectResults.detections.filter(d=>d.categories[0].categoryName==='person').length;

  const stats = [
    { label: 'OBJECTS', value: String(obj) },
    { label: 'PERSONS', value: String(pers) },
    { label: 'FACES', value: String(face) },
    { label: 'POSES', value: String(pose) },
    { label: 'PROC', value: `${procTime}MS` },
  ];

  let sx = 30;
  for (const s of stats) {
    ctx.font = '700 32px "Share Tech Mono", monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.fillText(s.value, sx, by + 42);
    ctx.font = '7px "Share Tech Mono", monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillText(s.label, sx, by + 58);
    sx += 140;
  }

  // RESTRICTED stamp right-aligned
  ctx.font = '700 18px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.textAlign = 'right';
  ctx.fillText('RESTRICTED', W - 30, by + 42);
  ctx.font = '7px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  ctx.fillText('AUTHORIZED PERSONNEL ONLY', W - 30, by + 58);
  ctx.textAlign = 'left';
}

/* ===== LAYER 9: System info panel (bottom-left, over photo) ===== */
function drawSystemPanel(ctx) {
  const px = 16, py = H - 310, pw = 460, ph = 120;
  drawPanel(ctx, px, py, pw, ph);

  ctx.font = '8px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.25)';
  const lines = [
    `SYSTEM: DARK SCANNER RECON v3.1.0`,
    `DETECTOR: EFFICIENTDET-LITE0 FP16 // BLAZEFACE // LANDMARKER-LITE`,
    `POSE: LANDMARKER-LITE (33PT)  OPERATOR: [REDACTED]`,
    `AUTH: ${randHex(8)}-${randHex(4)}-${randHex(4)}`,
    `SESSION: DS-${Date.now().toString(36).toUpperCase()}  UPTIME: ${randInt(1,72)}H ${randInt(0,59)}M`,
  ];
  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], px + 14, py + 18 + i * 16);
  }

  // Small barcode inside panel
  drawBarcode(ctx, px + 14, py + ph - 24, 200, 14);
}

/* ===== LAYER 10: Bottom footer (over photo) ===== */
function drawBottomFooter(ctx) {
  const fy = H - 170;
  drawPanel(ctx, 0, fy, W, 170, { bg: 'rgba(0,0,0,0.6)', border: false });

  // Thin top line
  ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(20, fy + 4); ctx.lineTo(W - 20, fy + 4); ctx.stroke();

  // Tagline
  ctx.font = '700 13px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.fillText('TACTICAL IMAGE ANALYSIS', 20, fy + 30);
  ctx.fillText('FOR MODERN SURVEILLANCE', 20, fy + 48);

  // URL
  ctx.font = '8px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.fillText('HTTPS://PAUL13131313.GITHUB.IO/DARK-SCANNER', 20, fy + 72);

  // Brand right
  ctx.font = '700 14px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.textAlign = 'right';
  ctx.fillText('DSK.SYSTEMS', W - 20, fy + 30);
  ctx.font = '8px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.25)';
  ctx.fillText('暗号走査系統', W - 20, fy + 48);
  ctx.textAlign = 'left';

  // Barcode (bottom left)
  drawBarcode(ctx, 20, H - 70, 300, 28);
  ctx.font = '7px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  const now = new Date();
  ctx.fillText(`DSK-${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}-${randHex(6)}`, 20, H - 36);

  // QR block (bottom right)
  drawQRBlock(ctx, W - 90, H - 90, 3.5, 20, 20);
  ctx.font = '7px "Share Tech Mono", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  ctx.textAlign = 'right';
  ctx.fillText(randHex(12), W - 20, H - 10);
  ctx.textAlign = 'left';

  // Number row (01 02 ... 08)
  ctx.font = '9px "Share Tech Mono", monospace';
  const nrY = fy + 90;
  for (let i = 1; i <= 8; i++) {
    const nx = 20 + (i - 1) * 48;
    ctx.fillStyle = i === 4 ? 'rgba(255,255,255,0.7)' : 'rgba(255,255,255,0.15)';
    ctx.fillText(String(i).padStart(2, '0'), nx, nrY);
    if (i === 4) {
      ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(nx, nrY + 3); ctx.lineTo(nx + 14, nrY + 3); ctx.stroke();
    }
  }
}

/* ===== LAYER 11: Scanlines ===== */
function drawScanlines(ctx) {
  ctx.fillStyle = 'rgba(0,0,0,0.03)';
  for (let y = 0; y < H; y += 4) ctx.fillRect(0, y, W, 2);
}

/* ===== MASTER RENDER ===== */
async function renderHUD(sourceImage, results) {
  await document.fonts.ready;
  const ctx = hudCtx;
  ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';

  // Layer 1: Photo fills entire canvas
  drawPhoto(ctx, sourceImage);

  // Layer 2: X-cross + grid
  drawCrossLines(ctx);

  // Layer 3: Detection overlays
  drawDetections(ctx, results, sourceImage);

  // Layer 4: Giant typography
  drawGiantText(ctx);

  // Layer 5: Header panel
  drawHeaderPanel(ctx);

  // Layer 6: Left data panel
  drawLeftPanel(ctx, results);

  // Layer 7: Right side panels
  drawRightPanels(ctx, sourceImage, results);

  // Layer 8: Stats strip
  drawStatsBanner(ctx, results, results.procTime);

  // Layer 9: System panel
  drawSystemPanel(ctx);

  // Layer 10: Bottom footer
  drawBottomFooter(ctx);

  // Layer 11: Global effects
  drawCornerBrackets(ctx, 4, 4, W-8, H-8, 40, 1.5, 'rgba(255,255,255,0.08)');
  drawScanlines(ctx);
}

/* ===== PNG SAVE ===== */
function savePNG() {
  hudCanvas.toBlob(async (blob) => {
    const filename = `dark-scanner-${Date.now()}.png`;
    if (navigator.share && navigator.canShare) {
      const file = new File([blob], filename, { type: 'image/png' });
      const shareData = { files: [file] };
      if (navigator.canShare(shareData)) {
        try {
          await navigator.share(shareData);
          return;
        } catch (e) {
          // User cancelled or share failed, fall through to download
        }
      }
    }
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  }, 'image/png');
}

/* ===== EVENT HANDLERS ===== */
btnCamera.addEventListener('click', async () => {
  showScreen('camera-screen');
  await startCamera();
});

btnUpload.addEventListener('click', () => {
  fileInput.click();
});

btnGallery.addEventListener('click', () => {
  fileInput.click();
});

fileInput.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  stopCamera();

  const img = new Image();
  img.onload = async () => {
    const results = await analyzeImage(img);
    await renderHUD(img, results);
    showScreen('result-screen');
    URL.revokeObjectURL(img.src);
  };
  img.src = URL.createObjectURL(file);
  e.target.value = '';
});

btnScan.addEventListener('click', async () => {
  const capturedCanvas = captureFrame();
  stopCamera();

  const img = new Image();
  img.onload = async () => {
    const results = await analyzeImage(img);
    await renderHUD(img, results);
    showScreen('result-screen');
  };
  img.src = capturedCanvas.toDataURL();
});

btnFlip.addEventListener('click', async () => {
  currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
  await startCamera();
});

btnBackStart.addEventListener('click', () => {
  stopCamera();
  showScreen('start-screen');
});

btnSave.addEventListener('click', savePNG);

btnNew.addEventListener('click', () => {
  showScreen('start-screen');
});

/* ===== INIT ===== */
initModels();
</script>
</body>
</html>
